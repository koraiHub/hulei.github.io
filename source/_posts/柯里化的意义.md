---
title: 柯里化的意义
date: 2016-11-12 12:35:26
tags:
---

最近某个技术群中有人激进的表达绝不用**lodash**，称lodash作者态度傲慢，自己只用**ramda**，于是我很好奇，研究了一会ramda，引申出下面的思考。

粗略看ramda官方文档不会觉得与lodash有什么不同，但实际上这两者的设计理念很不一样，如果把另一个著名的类库underscore也放到一起对比，大多数人的看法是这样的：

> underscore < lodash < ramda

ramda被一些人认为强于lodash的一个重要的原因就是将柯里化的思想体现在api设计中。

官方描述ramda的主要特性也说到，ramda就是为此设计的：

>* Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.
>* Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.
>* The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.
>
>The last two points together make it very easy to build functions as sequences of simpler functions, each of which transforms the data and passes it along to the next. Ramda is designed to support this style of coding.

## 什么是柯里化

柯里化存在函数式编程中。在支持高阶函数（参数或返回值包含函数的函数）的语言里（如python，javascript），柯里化的产生是自然而然的。

我们用实例来说明，观察以下python代码：

```Python
a = map(lambda x: x*2, [1,2,3])
b = map(lambda x: x*2, [4,5,6])
c = map(lambda x: x*2, [7,8,9])
```

抽象是程序员的基本素养，上面的代码lambda函数多次使用，不够优雅切不易维护，我们会想到这样改进：

```python
double = lambda x: x*2

a = map(double, [1,2,3])
b = map(double, [4,5,6])
c = map(double, [7,8,9])
```

如此一来，当业务逻辑有变，我们只需要修改double变量。

看上去已经足够了，但`map(double...`不够语义化，试想别人在解读这段代码的时候会这样想：

“遍历这个list，将double函数作用在每一个元素上，返回一个新的list。”

若不是double函数名已经足够语义化，我们还得翻看double函数的定义，看看它到底做了什么。是否可以再抽象一点，像下面这样调用： 

```python
a = getEachItemDoubled([1,2,3])
b = getEachItemDoubled([4,5,6])
c = getEachItemDoubled([7,8,9])
```

函数名清晰明确的表达了代码的意图，即使我们没有添加任何注释，谁都明白`getEachItemDoubled`做了什么。

这样的`getEachItemDoubled`函数该怎么定义？

考虑下面的代码。

```Python
def curredMap(fn):
    def p(x):
        return map(fn, x)
	return p

getEachItemDoubled = curredMap(lambda x:x*2)
```

**curredMap**和map一样也是个高阶函数，在这段代码中非常重要。如上，现在你可以用你希望的方式使用更语义的`getEachItemDoubled`。

有了`curredMap`函数，你还可以这样：

```python
# 定义一个函数，用于将list每一个元素乘以3
getEachItemTripled = curredMap(lambda x: x*3)

# 定义一个函数，用于将list每个元素字符串化
strEachItem = curredMap(lambda x: str(x))

a = getEachItemTripled([1,2,3]) # [3, 6, 9]
b = strEachItem([1,2,3]) # ['1', '2', '3']
```

看到这你大概明白了，简而言之，柯里化就是函数的**局部调用**，也称**部分求值**，下面会进一步解释。

## 柯里化的意义

上面的例子中，我们对python的内置函数map做了**部分求值**得到了更加抽象的`getEachItemDoubled`、`getEachItemTripled`以及`strEachItem`，多参函数map变成了一些单参函数。

原生map函数依赖两个参数，我们没有办法这样使用：

```python
getEachItemDoubled = map(lambda x:x*2)
# TypeError: map() requires at least two args
```

编译器会抛出TypeError错误。 这样的设计在初学者看来非常痛苦，我需要记住每一个函数必须传递几个参数吗？

把最初的代码和最终柯里化后的代码放到一起：

```
a = map(lambda x: x*2, [1,2,3])

a = curredMap(lambda x: x*2)([1,2,3])
```

map被我们做了降阶处理，这样做有什么意义？

就上面的例子而言。

* 可读性更强。


* 接口简化。
* 复用性更高。

最重要的是：你不需要在脑海里记住map函数必须传递两个参数，尽管放心使用`curredMap`。

我们现在可以这么理解**局部调用**：map函数要求两个参数，但我只给了它一个参数，理应返回一个能够接收第二个参数的函数，无论我何时想要传递第二个参数，它都能正常工作。这就是柯里化出现的意义。

再用一段js代码来说明。

```Javascript
function sum(a, b){
  return a + b
}


function cu(x, y){
  function fn(z){
    return x + z
  }
  if(arguments.length === 1){
    return fn
  } 
  return x + y  
}

sum(1,2)
curredSum(1)(2)
```

curredSum看上去并没有比sum函数可读性更好，也不见得接口更简单，两者似乎没什么区别。

而curredSum的真正优势体现在下面这种情形中。

```javascript
/* 方式一 */
sum(1,2,3,4)
sum(1,2,3,7)
sum(1,2,3,11,12)
sum(1,2,3,11,12,14)
sum(1,2,3,11,12,17)
// ...

/* 方式二 */
var sixPlus = curredSum(1+2+3)
sixPlus(4)
sixPlus(7)
sixPlus(11)
var twentyNinePlus = curredSum(1+2+3+11+12)
twentyNinePlus(14)
twentyNinePlus(17)
// ...
```

若参数被多次复用，就应该抽象出来，无论怎么看，柯里化后的代码都更加容易维护和扩展，并且也不失易读性。

最后，我们来看看ramda中的柯里化。

```javascript
var R = require('ramda')

R.append('c', ['a','b']) // -> ['a','b','c']
/* 下面的函数作用是为数组追加一个'c' */
var appendC = R.append('c')
appendC(['a','b']) // -> ['a','b','c']
appendC([1,2,3]) // -> [1,2,3,'c']

R.remove(1,2,[1,2,3,4,5]) // -> [1,4]
/* 下面这个函数的作用是从[1,2,3,4,5]开始位置去除x个数，返回一个新的数组 */
/* R.__在这里作为占位符，表示柯里化后的函数形参应该传递的位置 */
var removeXFromStart = R.remove(0,R.__,[1,2,3,4,5])
removeXFromStart(2) // -> [3,4,5]
removeXFromStart(4) // -> [5]

/* 下面这个更复杂一点 */
/* t函数的作用是取出参数的x属性值，乘2，取反 */
var t = R.compose(R.negate, x => x*2, R.prop('x'))
t({
  x: 100,
  y: 200,
  z: 300
}) // -> -200
t({
  x: 1,
  y: 2
}) // -> -2
```

如果你用过lodash，你一定清楚上面的例子和lodash的区别，但lodash用户是否应该为此就过渡到ramda，推荐你看看Scott Sauyet写的[why ramda](http://fr.umio.us/why-ramda/)，以及google一下ramda和lodash的更多对比再做决定。

尽管以上说的都是柯里化为函数式编程带来的好处，我还是得说，理智的程序员还是应该谨慎使用这种编程方法。

不该使用柯里化的场景之一是：函数的参数总是需要多个同时传递，否则函数本身的语义就不明确，或者被破坏。例如一个函数定义为标出地图上的点，往往在使用它的时候经度和纬度会同时传入，无论你只传入经度还是纬度都显得很别扭，柯里化这样的函数没有意义，纯粹画蛇添足。

另外，我们应该思考，既然柯里化让一切那么美好，很多语言设计之初为什么让函数可以定义多个形参，为什么在这之上更衍生出了默认参数、可变参数、关键字参数？参数定义如此灵活是好是坏？

python由于tuple这种数据类型的存在，使得多参函数轻易的接受一个混合过后的tuple作为参数，并将其展开为多个参数，仿佛函数定义时的参数个数毫无约束性，多参函数仍然可以像单参函数一样使用，考量一个函数应该定义多参还是单参在python里似乎并不重要了，个人爱好这时候高于一切。仍然有很多使用多参函数的场景，大多数人可以熟练的将参数提前组合，柯里化只不过把步骤分解了。

在我看来，应不应该柯里化，只需考量一点，局部调用这个函数是否意义更明确。

强行柯里化也可能是灾难。
