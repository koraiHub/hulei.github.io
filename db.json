{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/github-commits.png","path":"images/github-commits.png","modified":0,"renderable":0},{"_id":"themes/typing/source/css/source.css","path":"css/source.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/js/typing.js","path":"js/typing.js","modified":0,"renderable":1},{"_id":"themes/typing/source/css/typing.css","path":"css/typing.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/typing/LICENSE","hash":"e4bf48251989dd666899d2d22b351b8db4764992","modified":1479275139000},{"_id":"themes/typing/README.md","hash":"c439580128aa5dda19e06db9f25f1e37f286063a","modified":1479275139000},{"_id":"themes/typing/_config.yml","hash":"299fa6819b9f0fc01170c8e70ba70e752a382d80","modified":1478769920000},{"_id":"themes/typing/makefile","hash":"5c63c52a6c85ce3d88ad41d4772f228899c1f504","modified":1479275139000},{"_id":"themes/typing/package.json","hash":"262a12df885c9eb894560d7f0cf7ca6315821953","modified":1479275139000},{"_id":"source/_posts/.Ulysses-Group.plist","hash":"e9130f5581fcbc18cd203de33148dd4e9a1b9ab5","modified":1481115234000},{"_id":"source/_posts/.Ulysses-favorites.plist","hash":"37829bb1864d5ed0da879929024e84ea638b3c0a","modified":1481115234000},{"_id":"source/_posts/万圣节下的github.md","hash":"4f3e90a887ff7dbd581dc903245cead1a6a4f997","modified":1482818984000},{"_id":"source/_posts/git-diff使用.md","hash":"2990019226b435229fcee31550440f6e662b4617","modified":1479274800000},{"_id":"source/_posts/一个有趣的this指向问题.md","hash":"bab318a2c399ec3c3bd7d2e282b2257491c70e0c","modified":1479274800000},{"_id":"source/_posts/JavaScript-Array-sort.md","hash":"ff4ce8796790aa4b73c7fbf8693bc4ffa3bb7e1e","modified":1481115236000},{"_id":"source/_posts/vim启动失败.md","hash":"67e69593170f358db2fbd56e3da13058a016dbb8","modified":1479274800000},{"_id":"source/images/github-commits.png","hash":"4d3d06878f58d72faecb540aefadd44050a8fbf9","modified":1482029623000},{"_id":"source/_posts/柯里化的意义.md","hash":"a0654751662b0b15e695345119a9d36691ab963c","modified":1479274800000},{"_id":"source/_posts/什么是模块.md","hash":"fdbf0d01a30608349d0d01eed9ed8d99dc89f448","modified":1479274800000},{"_id":"themes/typing/layout/layout.ejs","hash":"595a9150e0184ae221589ca6b454f3a9475591c6","modified":1481433106000},{"_id":"themes/typing/layout/index.ejs","hash":"18aaf3d920f7cae080932a909640754d69bbee1b","modified":1479275139000},{"_id":"themes/typing/layout/archive.ejs","hash":"1326b972ea3dcdc23a453e3c61709ffe561ed931","modified":1479275139000},{"_id":"themes/typing/layout/category.ejs","hash":"a6f14dc7f869d6cd0663fef8747c708cdbb18fe7","modified":1479275139000},{"_id":"themes/typing/languages/default.yml","hash":"bd8e9329c5636b85bc554b76f06830269869864d","modified":1479275139000},{"_id":"themes/typing/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1479275139000},{"_id":"themes/typing/layout/tag.ejs","hash":"b9558a0789e3549d6bbcaf86544af9bd3a7a472a","modified":1479275139000},{"_id":"themes/typing/layout/page.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1479275139000},{"_id":"themes/typing/languages/fr.yml","hash":"559b094ef6b9d02506c33044be8b50ebeda28a70","modified":1479275139000},{"_id":"themes/typing/languages/ru.yml","hash":"3d45b446862c8a305823533b868556f6111308fe","modified":1479275139000},{"_id":"themes/typing/languages/es.yml","hash":"23dc21c62927062829e31fcfd6c5d2c7e9257844","modified":1479275139000},{"_id":"themes/typing/languages/nl.yml","hash":"95fc8003c34e1353f73f6315291d0cb10b5d7e73","modified":1479275139000},{"_id":"themes/typing/languages/no.yml","hash":"53ba8ffd6353262138016bd1b4c3a65a113e6c52","modified":1479275139000},{"_id":"themes/typing/languages/zh-CN.yml","hash":"4f227318cce98303496e423d85de28b79fb01f00","modified":1479275139000},{"_id":"themes/typing/languages/zh-TW.yml","hash":"b68f12091eeae30b56847997d059f5ce29f086ac","modified":1479275139000},{"_id":"themes/typing/preview/preview.png","hash":"33b39c8a626db45ee473ce3e3d0e37ebd9fb83d3","modified":1479275139000},{"_id":"themes/typing/source/css/source.css","hash":"93078434d298038b963c165b31a497cc517b0baf","modified":1479275139000},{"_id":"themes/typing/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479275139000},{"_id":"themes/typing/source/js/typing.js","hash":"e1de54745c5df13cc207ca4bd2e4e02b2e5a31be","modified":1479275139000},{"_id":"themes/typing/source/css/typing.css","hash":"eab2f172f9fb44d460babc971b42dca92eef3e3b","modified":1479275139000},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479275139000},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479275139000},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479275139000},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479275139000},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479275139000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1479275139000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1479275139000},{"_id":"themes/typing/layout/_partial/archive.ejs","hash":"9665ed77377c8eb15d94c04a33905d26704f2e13","modified":1479275139000},{"_id":"themes/typing/layout/_partial/archive-post.ejs","hash":"877b0b79538a63f1ae73407e372ee041f8b65e1b","modified":1479275139000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1479275139000},{"_id":"themes/typing/layout/_partial/after-footer.ejs","hash":"7737fd36dffa21abdc1894413d4063d36edba5e7","modified":1479275139000},{"_id":"themes/typing/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1479275139000},{"_id":"themes/typing/layout/_partial/article.ejs","hash":"a7b3a3c51f8b089c752f475c2cb393d3fa73c010","modified":1479275139000},{"_id":"themes/typing/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1479275139000},{"_id":"themes/typing/layout/_partial/baidu_tongji.ejs","hash":"998936b5bf3fcef3b2de5e21fe24e956afa43f59","modified":1479275139000},{"_id":"themes/typing/layout/_partial/head.ejs","hash":"04133fd540fb4af025b57dcc9032c4b3db6058e4","modified":1479275139000},{"_id":"themes/typing/layout/_partial/header.ejs","hash":"6c23f09fc807e2b3779d5f252503fd60edb77892","modified":1485698319000},{"_id":"themes/typing/layout/_partial/footer.ejs","hash":"9562eeb5a57d0a5115329f28f2fa0044c63f71f6","modified":1485698268000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1479275139000},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1479275139000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1479275139000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1479275139000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1479275139000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/date.ejs","hash":"38affd429d5ed376b349219f3094a7d530c58a70","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/category.ejs","hash":"6cd9c85b105db04a74678d0a6c5440e51d9d84f7","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/nav.ejs","hash":"93e594128978c0e7310c9aef3e150effbf549f0e","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/tag.ejs","hash":"90209686eabc6c3e7a6a7ef2defd0b84611d9f41","modified":1479275139000},{"_id":"themes/typing/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1479275139000},{"_id":"public/2016/10/09/git-diff使用/index.html","hash":"2e9fc0ff1b93df6055b7158c0219f710b6da5d3c","modified":1485698368744},{"_id":"public/archives/index.html","hash":"06471d79747c26383ceaed38cfa463a2e4b67425","modified":1485698368745},{"_id":"public/2016/07/27/一个有趣的this指向问题/index.html","hash":"b83ffbf9fd290aa5e90db79e56acecccec41b9d2","modified":1485698368745},{"_id":"public/2016/06/15/vim启动失败/index.html","hash":"0e2caa7cb938edad291f140bce72a0fbc31582be","modified":1485698368745},{"_id":"public/2016/11/12/柯里化的意义/index.html","hash":"02ff8f566e989c72be0fa52075f1d3b6e3a54149","modified":1485698368747},{"_id":"public/2016/11/07/什么是模块/index.html","hash":"3cc0b96060e06eefd45859f990aca2d466dc554c","modified":1485698368746},{"_id":"public/2016/12/18/万圣节下的github/index.html","hash":"2ad59caf88fbf247f788b13c375f69ead5d4c084","modified":1485698368745},{"_id":"public/2016/11/25/JavaScript-Array-sort/index.html","hash":"7d6d11ffaef626c8019254cf4c3b4f9156dacef1","modified":1485698368744},{"_id":"public/archives/2016/index.html","hash":"ec22f8f2c02740701bca33b47e8e34dea284a806","modified":1485698368745},{"_id":"public/archives/2016/10/index.html","hash":"60a1ec603e43dec9c4eed68ff7d67a4742f01cdb","modified":1485698368745},{"_id":"public/archives/2016/06/index.html","hash":"acad20638d18c7a07e1936e0c9fd65eb33f1058e","modified":1485698368745},{"_id":"public/archives/2016/11/index.html","hash":"ef299f99503c5eff63486ecd6f7e72a3c575057d","modified":1485698368745},{"_id":"public/index.html","hash":"be01bc938f21c09cd93eda30294b494bdf87a930","modified":1485698368746},{"_id":"public/archives/2016/07/index.html","hash":"ef1fcaaa98b7dcb8e2c08f368e2a5146bed219a2","modified":1485698368746},{"_id":"public/archives/2016/12/index.html","hash":"bc8651f5cb1aad69005fb2bfb7de839892de8b65","modified":1485698368746},{"_id":"public/images/github-commits.png","hash":"4d3d06878f58d72faecb540aefadd44050a8fbf9","modified":1485693423224},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1485163607000},{"_id":"themes/typing/.gitignore","hash":"d83e98433e68316c1ba1260e46463447ad71aaa1","modified":1475108186000},{"_id":"source/_drafts/redis操作中的原子性问题.md","hash":"d61d14317a527c018b3616dc5eb55612c6af9b1f","modified":1485256247000},{"_id":"source/_drafts/专注一点.md","hash":"32a46063c27b8371177a5dbefd5614d2950dcf4f","modified":1485399548000},{"_id":"source/_posts/面试中的问题.md","hash":"8156083c67184d22b8e1ef87aa9a5e6cd99f22fb","modified":1485693102000},{"_id":"public/2017/01/29/面试中的问题/index.html","hash":"65af4e9bfd1841d4458dc0be4a4df0fbc149f7a7","modified":1485698368747},{"_id":"public/archives/2017/01/index.html","hash":"019dad1e10ad4391e6223e29106f181020e5c8f5","modified":1485698368745},{"_id":"public/archives/2017/index.html","hash":"af063098a7c9de110dd93da26e2114441f4f7f67","modified":1485698368746},{"_id":"themes/typing/layout/_partial/.header.ejs.swp","hash":"77f80decfdd54ae23f97eb9da80db1b702075e57","modified":1485698144000},{"_id":"public/atom.xml","hash":"a425a6897230b132c9a833ce4aebcdf89278596a","modified":1485698368746}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"万圣节下的github","date":"2016-12-18T02:50:10.000Z","_content":"\n![](/images/github-commits.png)\n\n昨天起公司不再使用github做代码托管，谨以万圣节下的这张截图合影留念。\n","source":"_posts/万圣节下的github.md","raw":"---\ntitle: 万圣节下的github\ndate: 2016-12-18 10:50:10\ntags:\n---\n\n![](/images/github-commits.png)\n\n昨天起公司不再使用github做代码托管，谨以万圣节下的这张截图合影留念。\n","slug":"万圣节下的github","published":1,"updated":"2016-12-27T06:09:44.000Z","_id":"ciwu2eol600004n9kzseesmko","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/github-commits.png\" alt=\"\"></p>\n<p>昨天起公司不再使用github做代码托管，谨以万圣节下的这张截图合影留念。</p>\n","excerpt":"","more":"<p><img src=\"/images/github-commits.png\" alt=\"\"></p>\n<p>昨天起公司不再使用github做代码托管，谨以万圣节下的这张截图合影留念。</p>\n"},{"title":"git diff使用","date":"2016-10-09T03:02:24.000Z","_content":"\n​ diff命令平时没少用，但一直使用的只有下面两条：\n\n* 比较分支：`git diff master..another`\n\n\n* 查看目前修改了的内容：仅输入`git diff`\n\n\n  实际上，diff是个很强大的命令，能够找出项目里任意两次提交之间的改动。\n\n  \\#\\# 已经添加到暂存区的修改\n\n  `git diff --cached`\n\n  没有`--cached`选项的命令查看工作区修改，而上面的命令用户查看暂存区的修改和本地当前索引间的差异，不难理解，在下一次commit时提交的就是这些内容。\n\n  \\#\\# 当前索引与上一次提交之间的差别\n\n  `git diff HEAD`\n\n  \\#\\# 当前文件目录与另一个分支之间的差别\n\n  `git diff branchname`\n\n  \\#\\# 路径限定符`—`\n\n  `git diff — app.js`，`git diff -- xxx`\n\n  上面第一个命令显示了我对app.js文件的修改。第二个命令显示了xxx目录下(如果xxx是目录名的话)所有文件的修改。\n\n  \\#\\# 综合使用\n\n  结合以上命令，如果有这样的需求：查看根目录app.js文件在分支A和分支B有什么不同，就可以用下面这个命令。\n\n  `git diff A..B -- app.js`\n\n","source":"_posts/git-diff使用.md","raw":"---\ntitle: git diff使用\ndate: 2016-10-09 11:02:24\ntags:\n---\n\n​ diff命令平时没少用，但一直使用的只有下面两条：\n\n* 比较分支：`git diff master..another`\n\n\n* 查看目前修改了的内容：仅输入`git diff`\n\n\n  实际上，diff是个很强大的命令，能够找出项目里任意两次提交之间的改动。\n\n  \\#\\# 已经添加到暂存区的修改\n\n  `git diff --cached`\n\n  没有`--cached`选项的命令查看工作区修改，而上面的命令用户查看暂存区的修改和本地当前索引间的差异，不难理解，在下一次commit时提交的就是这些内容。\n\n  \\#\\# 当前索引与上一次提交之间的差别\n\n  `git diff HEAD`\n\n  \\#\\# 当前文件目录与另一个分支之间的差别\n\n  `git diff branchname`\n\n  \\#\\# 路径限定符`—`\n\n  `git diff — app.js`，`git diff -- xxx`\n\n  上面第一个命令显示了我对app.js文件的修改。第二个命令显示了xxx目录下(如果xxx是目录名的话)所有文件的修改。\n\n  \\#\\# 综合使用\n\n  结合以上命令，如果有这样的需求：查看根目录app.js文件在分支A和分支B有什么不同，就可以用下面这个命令。\n\n  `git diff A..B -- app.js`\n\n","slug":"git-diff使用","published":1,"updated":"2016-11-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eola00014n9kn1eoilb8","content":"<p>​ diff命令平时没少用，但一直使用的只有下面两条：</p>\n<ul>\n<li>比较分支：<code>git diff master..another</code></li>\n</ul>\n<ul>\n<li>查看目前修改了的内容：仅输入<code>git diff</code></li>\n</ul>\n<p>  实际上，diff是个很强大的命令，能够找出项目里任意两次提交之间的改动。</p>\n<p>  ## 已经添加到暂存区的修改</p>\n<p>  <code>git diff --cached</code></p>\n<p>  没有<code>--cached</code>选项的命令查看工作区修改，而上面的命令用户查看暂存区的修改和本地当前索引间的差异，不难理解，在下一次commit时提交的就是这些内容。</p>\n<p>  ## 当前索引与上一次提交之间的差别</p>\n<p>  <code>git diff HEAD</code></p>\n<p>  ## 当前文件目录与另一个分支之间的差别</p>\n<p>  <code>git diff branchname</code></p>\n<p>  ## 路径限定符<code>—</code></p>\n<p>  <code>git diff — app.js</code>，<code>git diff -- xxx</code></p>\n<p>  上面第一个命令显示了我对app.js文件的修改。第二个命令显示了xxx目录下(如果xxx是目录名的话)所有文件的修改。</p>\n<p>  ## 综合使用</p>\n<p>  结合以上命令，如果有这样的需求：查看根目录app.js文件在分支A和分支B有什么不同，就可以用下面这个命令。</p>\n<p>  <code>git diff A..B -- app.js</code></p>\n","excerpt":"","more":"<p>​ diff命令平时没少用，但一直使用的只有下面两条：</p>\n<ul>\n<li>比较分支：<code>git diff master..another</code></li>\n</ul>\n<ul>\n<li>查看目前修改了的内容：仅输入<code>git diff</code></li>\n</ul>\n<p>  实际上，diff是个很强大的命令，能够找出项目里任意两次提交之间的改动。</p>\n<p>  ## 已经添加到暂存区的修改</p>\n<p>  <code>git diff --cached</code></p>\n<p>  没有<code>--cached</code>选项的命令查看工作区修改，而上面的命令用户查看暂存区的修改和本地当前索引间的差异，不难理解，在下一次commit时提交的就是这些内容。</p>\n<p>  ## 当前索引与上一次提交之间的差别</p>\n<p>  <code>git diff HEAD</code></p>\n<p>  ## 当前文件目录与另一个分支之间的差别</p>\n<p>  <code>git diff branchname</code></p>\n<p>  ## 路径限定符<code>—</code></p>\n<p>  <code>git diff — app.js</code>，<code>git diff -- xxx</code></p>\n<p>  上面第一个命令显示了我对app.js文件的修改。第二个命令显示了xxx目录下(如果xxx是目录名的话)所有文件的修改。</p>\n<p>  ## 综合使用</p>\n<p>  结合以上命令，如果有这样的需求：查看根目录app.js文件在分支A和分支B有什么不同，就可以用下面这个命令。</p>\n<p>  <code>git diff A..B -- app.js</code></p>\n"},{"title":"一个有趣的this指向问题","date":"2016-07-27T02:39:55.000Z","_content":"\tlet obj = {\n\t\ttest: ()=>{\n\t\t\tconsole.log(this)\n\t\t}\n\t}\n\tobj.test() // this -> ？\n\t(obj.test = obj.test)() // this -> ？\n\t(false || obj.test)() // this -> ？\n\n这里考察了多个知识点。\n\n* 谁调用了this就指向谁\n* 匿名函数this指向window（特指在浏览器中）\n* 赋值语句返回__右值__\n* 逻辑或语句返回从左到右第一个真值，否则返回最后一个值\n\n理解了这几条再回头看问题就很简单了。\n\n三个this分别指向obj, window, window\n","source":"_posts/一个有趣的this指向问题.md","raw":"---\ntitle: 一个有趣的this指向问题\ndate: 2016-07-27 10:39:55\ntags:\n---\n\tlet obj = {\n\t\ttest: ()=>{\n\t\t\tconsole.log(this)\n\t\t}\n\t}\n\tobj.test() // this -> ？\n\t(obj.test = obj.test)() // this -> ？\n\t(false || obj.test)() // this -> ？\n\n这里考察了多个知识点。\n\n* 谁调用了this就指向谁\n* 匿名函数this指向window（特指在浏览器中）\n* 赋值语句返回__右值__\n* 逻辑或语句返回从左到右第一个真值，否则返回最后一个值\n\n理解了这几条再回头看问题就很简单了。\n\n三个this分别指向obj, window, window\n","slug":"一个有趣的this指向问题","published":1,"updated":"2016-11-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eolc00024n9kegexiuew","content":"<pre><code>let obj = {\n    test: ()=&gt;{\n        console.log(this)\n    }\n}\nobj.test() // this -&gt; ？\n(obj.test = obj.test)() // this -&gt; ？\n(false || obj.test)() // this -&gt; ？\n</code></pre><p>这里考察了多个知识点。</p>\n<ul>\n<li>谁调用了this就指向谁</li>\n<li>匿名函数this指向window（特指在浏览器中）</li>\n<li>赋值语句返回<strong>右值</strong></li>\n<li>逻辑或语句返回从左到右第一个真值，否则返回最后一个值</li>\n</ul>\n<p>理解了这几条再回头看问题就很简单了。</p>\n<p>三个this分别指向obj, window, window</p>\n","excerpt":"","more":"<pre><code>let obj = {\n    test: ()=&gt;{\n        console.log(this)\n    }\n}\nobj.test() // this -&gt; ？\n(obj.test = obj.test)() // this -&gt; ？\n(false || obj.test)() // this -&gt; ？\n</code></pre><p>这里考察了多个知识点。</p>\n<ul>\n<li>谁调用了this就指向谁</li>\n<li>匿名函数this指向window（特指在浏览器中）</li>\n<li>赋值语句返回<strong>右值</strong></li>\n<li>逻辑或语句返回从左到右第一个真值，否则返回最后一个值</li>\n</ul>\n<p>理解了这几条再回头看问题就很简单了。</p>\n<p>三个this分别指向obj, window, window</p>\n"},{"title":"JavaScript Array.sort","date":"2016-11-25T13:45:04.000Z","_content":"\n今天用js重温了几种排序算法，发现个很有意思的网站：[几种排序算法的动画演示](http://jsdo.it/norahiko/oxIy/fullscreen)\n\n一直以来对`Array.sort`有个不痛不痒的误解，认为它底层用了快速排序。实际上呢，这个api有时候用了快速排序、有时候用了归并排序、还有时候用了选择排序，取决于作用的数组对象，以及引擎。\n\n之所以引擎会有不同的实现， 是因为ECMAscript压根没规定要用什么算法实现。好奇心驱使检索了一会。\n\n---\n\n只所以有之前的误解是因为，既然快速排序被认可为已知的排序算法中最快的，有什么理由不用呢。反过来想，也许不用的理由也很简单，大概和快速排序本身是不稳定算法有关。\n\n\n\n在v8（chrome）里，作用在长度小于23的数组上用的是插入排序，而大于23的采用的是快速排序。\n\n快排的不稳定在于基准元素的选择和比较的方式，可能造成值相同的元素在排序后相对位置发生了变化，Safari、Firefox这两的引擎表示不能接受，选择了用归并排序来实现。\n\n> ```\n> The array is sorted on the key correctly, but where there are duplicate values\n> for the key, the original order is NOT preserved.\n> ```\n\n来自多年前Bugzilla上的这篇[report](https://bugzilla.mozilla.org/show_bug.cgi?id=224128)。一个叫*Martin Thomson*的人提出的bug。\n\nIE的实现则同样是稳定排序（测试如此），不过并没有找到用了什么排序方法。\n\n---\n\n引擎背后的实现其实不必太关心。\n\nsort的使用来复习一遍。列一个很多不熟悉Api的程序员常犯的错误，唯一的一个可选的参数并不是断言，该函数需要返回三个可能的值，例：\n\n```Javascript\nfoo.sort((a, b)=>{return a -  b})\n```\n\n* 若返回值大于0，a在b后\n* 若返回值等于0，位置不变\n* 若返回值小于0，a在b前\n\n如果传入断言，返回值只可能大于0或等于0，显然得不到想要的结果。\n\n并且要注意的是，这里比较的是数组元素的unicode编码，忽略这一点会对下面这个数组的排序疑惑（并不是想像中的从小到大排序）。\n\n```Javascript\n[2,1,10].sort() // [1,10,2]\n```\n\n（完）","source":"_posts/JavaScript-Array-sort.md","raw":"---\ntitle: JavaScript Array.sort\ndate: 2016-11-25 21:45:04\ntags:\n---\n\n今天用js重温了几种排序算法，发现个很有意思的网站：[几种排序算法的动画演示](http://jsdo.it/norahiko/oxIy/fullscreen)\n\n一直以来对`Array.sort`有个不痛不痒的误解，认为它底层用了快速排序。实际上呢，这个api有时候用了快速排序、有时候用了归并排序、还有时候用了选择排序，取决于作用的数组对象，以及引擎。\n\n之所以引擎会有不同的实现， 是因为ECMAscript压根没规定要用什么算法实现。好奇心驱使检索了一会。\n\n---\n\n只所以有之前的误解是因为，既然快速排序被认可为已知的排序算法中最快的，有什么理由不用呢。反过来想，也许不用的理由也很简单，大概和快速排序本身是不稳定算法有关。\n\n\n\n在v8（chrome）里，作用在长度小于23的数组上用的是插入排序，而大于23的采用的是快速排序。\n\n快排的不稳定在于基准元素的选择和比较的方式，可能造成值相同的元素在排序后相对位置发生了变化，Safari、Firefox这两的引擎表示不能接受，选择了用归并排序来实现。\n\n> ```\n> The array is sorted on the key correctly, but where there are duplicate values\n> for the key, the original order is NOT preserved.\n> ```\n\n来自多年前Bugzilla上的这篇[report](https://bugzilla.mozilla.org/show_bug.cgi?id=224128)。一个叫*Martin Thomson*的人提出的bug。\n\nIE的实现则同样是稳定排序（测试如此），不过并没有找到用了什么排序方法。\n\n---\n\n引擎背后的实现其实不必太关心。\n\nsort的使用来复习一遍。列一个很多不熟悉Api的程序员常犯的错误，唯一的一个可选的参数并不是断言，该函数需要返回三个可能的值，例：\n\n```Javascript\nfoo.sort((a, b)=>{return a -  b})\n```\n\n* 若返回值大于0，a在b后\n* 若返回值等于0，位置不变\n* 若返回值小于0，a在b前\n\n如果传入断言，返回值只可能大于0或等于0，显然得不到想要的结果。\n\n并且要注意的是，这里比较的是数组元素的unicode编码，忽略这一点会对下面这个数组的排序疑惑（并不是想像中的从小到大排序）。\n\n```Javascript\n[2,1,10].sort() // [1,10,2]\n```\n\n（完）","slug":"JavaScript-Array-sort","published":1,"updated":"2016-12-07T12:53:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eolf00034n9ks4gp5jwo","content":"<p>今天用js重温了几种排序算法，发现个很有意思的网站：<a href=\"http://jsdo.it/norahiko/oxIy/fullscreen\" target=\"_blank\" rel=\"external\">几种排序算法的动画演示</a></p>\n<p>一直以来对<code>Array.sort</code>有个不痛不痒的误解，认为它底层用了快速排序。实际上呢，这个api有时候用了快速排序、有时候用了归并排序、还有时候用了选择排序，取决于作用的数组对象，以及引擎。</p>\n<p>之所以引擎会有不同的实现， 是因为ECMAscript压根没规定要用什么算法实现。好奇心驱使检索了一会。</p>\n<hr>\n<p>只所以有之前的误解是因为，既然快速排序被认可为已知的排序算法中最快的，有什么理由不用呢。反过来想，也许不用的理由也很简单，大概和快速排序本身是不稳定算法有关。</p>\n<p>在v8（chrome）里，作用在长度小于23的数组上用的是插入排序，而大于23的采用的是快速排序。</p>\n<p>快排的不稳定在于基准元素的选择和比较的方式，可能造成值相同的元素在排序后相对位置发生了变化，Safari、Firefox这两的引擎表示不能接受，选择了用归并排序来实现。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; The array is sorted on the key correctly, but where there are duplicate values</div><div class=\"line\">&gt; for the key, the original order is NOT preserved.</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>来自多年前Bugzilla上的这篇<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=224128\" target=\"_blank\" rel=\"external\">report</a>。一个叫<em>Martin Thomson</em>的人提出的bug。</p>\n<p>IE的实现则同样是稳定排序（测试如此），不过并没有找到用了什么排序方法。</p>\n<hr>\n<p>引擎背后的实现其实不必太关心。</p>\n<p>sort的使用来复习一遍。列一个很多不熟悉Api的程序员常犯的错误，唯一的一个可选的参数并不是断言，该函数需要返回三个可能的值，例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo.sort(<span class=\"function\">(<span class=\"params\">a, b</span>)=&gt;</span>&#123;<span class=\"keyword\">return</span> a -  b&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>若返回值大于0，a在b后</li>\n<li>若返回值等于0，位置不变</li>\n<li>若返回值小于0，a在b前</li>\n</ul>\n<p>如果传入断言，返回值只可能大于0或等于0，显然得不到想要的结果。</p>\n<p>并且要注意的是，这里比较的是数组元素的unicode编码，忽略这一点会对下面这个数组的排序疑惑（并不是想像中的从小到大排序）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>].sort() <span class=\"comment\">// [1,10,2]</span></div></pre></td></tr></table></figure>\n<p>（完）</p>\n","excerpt":"","more":"<p>今天用js重温了几种排序算法，发现个很有意思的网站：<a href=\"http://jsdo.it/norahiko/oxIy/fullscreen\">几种排序算法的动画演示</a></p>\n<p>一直以来对<code>Array.sort</code>有个不痛不痒的误解，认为它底层用了快速排序。实际上呢，这个api有时候用了快速排序、有时候用了归并排序、还有时候用了选择排序，取决于作用的数组对象，以及引擎。</p>\n<p>之所以引擎会有不同的实现， 是因为ECMAscript压根没规定要用什么算法实现。好奇心驱使检索了一会。</p>\n<hr>\n<p>只所以有之前的误解是因为，既然快速排序被认可为已知的排序算法中最快的，有什么理由不用呢。反过来想，也许不用的理由也很简单，大概和快速排序本身是不稳定算法有关。</p>\n<p>在v8（chrome）里，作用在长度小于23的数组上用的是插入排序，而大于23的采用的是快速排序。</p>\n<p>快排的不稳定在于基准元素的选择和比较的方式，可能造成值相同的元素在排序后相对位置发生了变化，Safari、Firefox这两的引擎表示不能接受，选择了用归并排序来实现。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; The array is sorted on the key correctly, but where there are duplicate values</div><div class=\"line\">&gt; for the key, the original order is NOT preserved.</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>来自多年前Bugzilla上的这篇<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=224128\">report</a>。一个叫<em>Martin Thomson</em>的人提出的bug。</p>\n<p>IE的实现则同样是稳定排序（测试如此），不过并没有找到用了什么排序方法。</p>\n<hr>\n<p>引擎背后的实现其实不必太关心。</p>\n<p>sort的使用来复习一遍。列一个很多不熟悉Api的程序员常犯的错误，唯一的一个可选的参数并不是断言，该函数需要返回三个可能的值，例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo.sort(<span class=\"function\">(<span class=\"params\">a, b</span>)=&gt;</span>&#123;<span class=\"keyword\">return</span> a -  b&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>若返回值大于0，a在b后</li>\n<li>若返回值等于0，位置不变</li>\n<li>若返回值小于0，a在b前</li>\n</ul>\n<p>如果传入断言，返回值只可能大于0或等于0，显然得不到想要的结果。</p>\n<p>并且要注意的是，这里比较的是数组元素的unicode编码，忽略这一点会对下面这个数组的排序疑惑（并不是想像中的从小到大排序）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>].sort() <span class=\"comment\">// [1,10,2]</span></div></pre></td></tr></table></figure>\n<p>（完）</p>\n"},{"title":"vim启动失败`Library not loaded `","date":"2016-06-15T04:06:26.000Z","_content":"\n## 问题\n\n```\n`=\\> vim .vimrc\ndyld: Library not loaded: /usr/local/lib/libruby.2.2.0.dylib\n  Referenced from: /usr/local/bin/vim\n  Reason: image not found\n[1]()    85018 trace trap  vim .vimrc\n```\n\\`\n## 解决办法\n```\n`brew update\nbrew uninstall --force ruby\nbrew uninstall --force openssl\nbrew install openssl\nbrew link openssl --force\nbrew install rbenv\nrbenv install 2.2.0\nrbenv global 2.2.0\necho 'export PATH=/usr/local/bin:$PATH' \\>\\> /.zshrc\necho 'export PATH=$HOME/.rbenv/shims:$PATH' \\>\\> /.zshrc\nCONFIGURE_OPTS=\"--disable-install-rdoc --enable-shared\" rbenv install 2.2.0\nsudo ln -s /.rbenv/versions/2.2.0 /usr/local/opt/ruby\n```\n\\`\n再重装vim\n\n`sudo brew install vim`\n\n据说`brew update`失败的解决办法也是`brew update`，🙄️。\n","source":"_posts/vim启动失败.md","raw":"---\ntitle: vim启动失败`Library not loaded `\ndate: 2016-06-15 12:06:26\ntags:\n---\n\n## 问题\n\n```\n`=\\> vim .vimrc\ndyld: Library not loaded: /usr/local/lib/libruby.2.2.0.dylib\n  Referenced from: /usr/local/bin/vim\n  Reason: image not found\n[1]()    85018 trace trap  vim .vimrc\n```\n\\`\n## 解决办法\n```\n`brew update\nbrew uninstall --force ruby\nbrew uninstall --force openssl\nbrew install openssl\nbrew link openssl --force\nbrew install rbenv\nrbenv install 2.2.0\nrbenv global 2.2.0\necho 'export PATH=/usr/local/bin:$PATH' \\>\\> /.zshrc\necho 'export PATH=$HOME/.rbenv/shims:$PATH' \\>\\> /.zshrc\nCONFIGURE_OPTS=\"--disable-install-rdoc --enable-shared\" rbenv install 2.2.0\nsudo ln -s /.rbenv/versions/2.2.0 /usr/local/opt/ruby\n```\n\\`\n再重装vim\n\n`sudo brew install vim`\n\n据说`brew update`失败的解决办法也是`brew update`，🙄️。\n","slug":"vim启动失败","published":1,"updated":"2016-11-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eolg00044n9ktbtud9ec","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">`=\\&gt; vim .vimrc</div><div class=\"line\">dyld: Library not loaded: /usr/local/lib/libruby.2.2.0.dylib</div><div class=\"line\">  Referenced from: /usr/local/bin/vim</div><div class=\"line\">  Reason: image not found</div><div class=\"line\">[1]()    85018 trace trap  vim .vimrc</div></pre></td></tr></table></figure>\n<p>`</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">`brew update</div><div class=\"line\">brew uninstall --force ruby</div><div class=\"line\">brew uninstall --force openssl</div><div class=\"line\">brew install openssl</div><div class=\"line\">brew link openssl --force</div><div class=\"line\">brew install rbenv</div><div class=\"line\">rbenv install 2.2.0</div><div class=\"line\">rbenv global 2.2.0</div><div class=\"line\">echo &apos;export PATH=/usr/local/bin:$PATH&apos; \\&gt;\\&gt; /.zshrc</div><div class=\"line\">echo &apos;export PATH=$HOME/.rbenv/shims:$PATH&apos; \\&gt;\\&gt; /.zshrc</div><div class=\"line\">CONFIGURE_OPTS=&quot;--disable-install-rdoc --enable-shared&quot; rbenv install 2.2.0</div><div class=\"line\">sudo ln -s /.rbenv/versions/2.2.0 /usr/local/opt/ruby</div></pre></td></tr></table></figure>\n<p>`<br>再重装vim</p>\n<p><code>sudo brew install vim</code></p>\n<p>据说<code>brew update</code>失败的解决办法也是<code>brew update</code>，🙄️。</p>\n","excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">`=\\&gt; vim .vimrc</div><div class=\"line\">dyld: Library not loaded: /usr/local/lib/libruby.2.2.0.dylib</div><div class=\"line\">  Referenced from: /usr/local/bin/vim</div><div class=\"line\">  Reason: image not found</div><div class=\"line\">[1]()    85018 trace trap  vim .vimrc</div></pre></td></tr></table></figure>\n<p>`</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">`brew update</div><div class=\"line\">brew uninstall --force ruby</div><div class=\"line\">brew uninstall --force openssl</div><div class=\"line\">brew install openssl</div><div class=\"line\">brew link openssl --force</div><div class=\"line\">brew install rbenv</div><div class=\"line\">rbenv install 2.2.0</div><div class=\"line\">rbenv global 2.2.0</div><div class=\"line\">echo &apos;export PATH=/usr/local/bin:$PATH&apos; \\&gt;\\&gt; /.zshrc</div><div class=\"line\">echo &apos;export PATH=$HOME/.rbenv/shims:$PATH&apos; \\&gt;\\&gt; /.zshrc</div><div class=\"line\">CONFIGURE_OPTS=&quot;--disable-install-rdoc --enable-shared&quot; rbenv install 2.2.0</div><div class=\"line\">sudo ln -s /.rbenv/versions/2.2.0 /usr/local/opt/ruby</div></pre></td></tr></table></figure>\n<p>`<br>再重装vim</p>\n<p><code>sudo brew install vim</code></p>\n<p>据说<code>brew update</code>失败的解决办法也是<code>brew update</code>，🙄️。</p>\n"},{"title":"柯里化的意义","date":"2016-11-12T04:35:26.000Z","_content":"\n最近某个技术群中有人激进的表达绝不用**lodash**，称lodash作者态度傲慢，自己只用**ramda**，于是我很好奇，研究了一会ramda，引申出下面的思考。\n\n粗略看ramda官方文档不会觉得与lodash有什么不同，但实际上这两者的设计理念很不一样，如果把另一个著名的类库underscore也放到一起对比，大多数人的看法是这样的：\n\n> underscore < lodash < ramda\n\nramda被一些人认为强于lodash的一个重要的原因就是将柯里化的思想体现在api设计中。\n\n官方描述ramda的主要特性也说到，ramda就是为此设计的：\n\n>* Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.\n>* Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.\n>* The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.\n>\n>The last two points together make it very easy to build functions as sequences of simpler functions, each of which transforms the data and passes it along to the next. Ramda is designed to support this style of coding.\n\n## 什么是柯里化\n\n柯里化存在函数式编程中。在支持高阶函数（参数或返回值包含函数的函数）的语言里（如python，javascript），柯里化的产生是自然而然的。\n\n我们用实例来说明，观察以下python代码：\n\n```Python\na = map(lambda x: x*2, [1,2,3])\nb = map(lambda x: x*2, [4,5,6])\nc = map(lambda x: x*2, [7,8,9])\n```\n\n抽象是程序员的基本素养，上面的代码lambda函数多次使用，不够优雅切不易维护，我们会想到这样改进：\n\n```python\ndouble = lambda x: x*2\n\na = map(double, [1,2,3])\nb = map(double, [4,5,6])\nc = map(double, [7,8,9])\n```\n\n如此一来，当业务逻辑有变，我们只需要修改double变量。\n\n看上去已经足够了，但`map(double...`不够语义化，试想别人在解读这段代码的时候会这样想：\n\n“遍历这个list，将double函数作用在每一个元素上，返回一个新的list。”\n\n若不是double函数名已经足够语义化，我们还得翻看double函数的定义，看看它到底做了什么。是否可以再抽象一点，像下面这样调用： \n\n```python\na = getEachItemDoubled([1,2,3])\nb = getEachItemDoubled([4,5,6])\nc = getEachItemDoubled([7,8,9])\n```\n\n函数名清晰明确的表达了代码的意图，即使我们没有添加任何注释，谁都明白`getEachItemDoubled`做了什么。\n\n这样的`getEachItemDoubled`函数该怎么定义？\n\n考虑下面的代码。\n\n```Python\ndef curredMap(fn):\n    def p(x):\n        return map(fn, x)\n\treturn p\n\ngetEachItemDoubled = curredMap(lambda x:x*2)\n```\n\n**curredMap**和map一样也是个高阶函数，在这段代码中非常重要。如上，现在你可以用你希望的方式使用更语义的`getEachItemDoubled`。\n\n有了`curredMap`函数，你还可以这样：\n\n```python\n# 定义一个函数，用于将list每一个元素乘以3\ngetEachItemTripled = curredMap(lambda x: x*3)\n\n# 定义一个函数，用于将list每个元素字符串化\nstrEachItem = curredMap(lambda x: str(x))\n\na = getEachItemTripled([1,2,3]) # [3, 6, 9]\nb = strEachItem([1,2,3]) # ['1', '2', '3']\n```\n\n看到这你大概明白了，简而言之，柯里化就是函数的**局部调用**，也称**部分求值**，下面会进一步解释。\n\n## 柯里化的意义\n\n上面的例子中，我们对python的内置函数map做了**部分求值**得到了更加抽象的`getEachItemDoubled`、`getEachItemTripled`以及`strEachItem`，多参函数map变成了一些单参函数。\n\n原生map函数依赖两个参数，我们没有办法这样使用：\n\n```python\ngetEachItemDoubled = map(lambda x:x*2)\n# TypeError: map() requires at least two args\n```\n\n编译器会抛出TypeError错误。 这样的设计在初学者看来非常痛苦，我需要记住每一个函数必须传递几个参数吗？\n\n把最初的代码和最终柯里化后的代码放到一起：\n\n```\na = map(lambda x: x*2, [1,2,3])\n\na = curredMap(lambda x: x*2)([1,2,3])\n```\n\nmap被我们做了降阶处理，这样做有什么意义？\n\n就上面的例子而言。\n\n* 可读性更强。\n\n\n* 接口简化。\n* 复用性更高。\n\n最重要的是：你不需要在脑海里记住map函数必须传递两个参数，尽管放心使用`curredMap`。\n\n我们现在可以这么理解**局部调用**：map函数要求两个参数，但我只给了它一个参数，理应返回一个能够接收第二个参数的函数，无论我何时想要传递第二个参数，它都能正常工作。这就是柯里化出现的意义。\n\n再用一段js代码来说明。\n\n```Javascript\nfunction sum(a, b){\n  return a + b\n}\n\n\nfunction cu(x, y){\n  function fn(z){\n    return x + z\n  }\n  if(arguments.length === 1){\n    return fn\n  } \n  return x + y  \n}\n\nsum(1,2)\ncurredSum(1)(2)\n```\n\ncurredSum看上去并没有比sum函数可读性更好，也不见得接口更简单，两者似乎没什么区别。\n\n而curredSum的真正优势体现在下面这种情形中。\n\n```javascript\n/* 方式一 */\nsum(1,2,3,4)\nsum(1,2,3,7)\nsum(1,2,3,11,12)\nsum(1,2,3,11,12,14)\nsum(1,2,3,11,12,17)\n// ...\n\n/* 方式二 */\nvar sixPlus = curredSum(1+2+3)\nsixPlus(4)\nsixPlus(7)\nsixPlus(11)\nvar twentyNinePlus = curredSum(1+2+3+11+12)\ntwentyNinePlus(14)\ntwentyNinePlus(17)\n// ...\n```\n\n若参数被多次复用，就应该抽象出来，无论怎么看，柯里化后的代码都更加容易维护和扩展，并且也不失易读性。\n\n最后，我们来看看ramda中的柯里化。\n\n```javascript\nvar R = require('ramda')\n\nR.append('c', ['a','b']) // -> ['a','b','c']\n/* 下面的函数作用是为数组追加一个'c' */\nvar appendC = R.append('c')\nappendC(['a','b']) // -> ['a','b','c']\nappendC([1,2,3]) // -> [1,2,3,'c']\n\nR.remove(1,2,[1,2,3,4,5]) // -> [1,4]\n/* 下面这个函数的作用是从[1,2,3,4,5]开始位置去除x个数，返回一个新的数组 */\n/* R.__在这里作为占位符，表示柯里化后的函数形参应该传递的位置 */\nvar removeXFromStart = R.remove(0,R.__,[1,2,3,4,5])\nremoveXFromStart(2) // -> [3,4,5]\nremoveXFromStart(4) // -> [5]\n\n/* 下面这个更复杂一点 */\n/* t函数的作用是取出参数的x属性值，乘2，取反 */\nvar t = R.compose(R.negate, x => x*2, R.prop('x'))\nt({\n  x: 100,\n  y: 200,\n  z: 300\n}) // -> -200\nt({\n  x: 1,\n  y: 2\n}) // -> -2\n```\n\n如果你用过lodash，你一定清楚上面的例子和lodash的区别，但lodash用户是否应该为此就过渡到ramda，推荐你看看Scott Sauyet写的[why ramda](http://fr.umio.us/why-ramda/)，以及google一下ramda和lodash的更多对比再做决定。\n\n尽管以上说的都是柯里化为函数式编程带来的好处，我还是得说，理智的程序员还是应该谨慎使用这种编程方法。\n\n不该使用柯里化的场景之一是：函数的参数总是需要多个同时传递，否则函数本身的语义就不明确，或者被破坏。例如一个函数定义为标出地图上的点，往往在使用它的时候经度和纬度会同时传入，无论你只传入经度还是纬度都显得很别扭，柯里化这样的函数没有意义，纯粹画蛇添足。\n\n另外，我们应该思考，既然柯里化让一切那么美好，很多语言设计之初为什么让函数可以定义多个形参，为什么在这之上更衍生出了默认参数、可变参数、关键字参数？参数定义如此灵活是好是坏？\n\npython由于tuple这种数据类型的存在，使得多参函数轻易的接受一个混合过后的tuple作为参数，并将其展开为多个参数，仿佛函数定义时的参数个数毫无约束性，多参函数仍然可以像单参函数一样使用，考量一个函数应该定义多参还是单参在python里似乎并不重要了，个人爱好这时候高于一切。仍然有很多使用多参函数的场景，大多数人可以熟练的将参数提前组合，柯里化只不过把步骤分解了。\n\n在我看来，应不应该柯里化，只需考量一点，局部调用这个函数是否意义更明确。\n\n强行柯里化也可能是灾难。\n","source":"_posts/柯里化的意义.md","raw":"---\ntitle: 柯里化的意义\ndate: 2016-11-12 12:35:26\ntags:\n---\n\n最近某个技术群中有人激进的表达绝不用**lodash**，称lodash作者态度傲慢，自己只用**ramda**，于是我很好奇，研究了一会ramda，引申出下面的思考。\n\n粗略看ramda官方文档不会觉得与lodash有什么不同，但实际上这两者的设计理念很不一样，如果把另一个著名的类库underscore也放到一起对比，大多数人的看法是这样的：\n\n> underscore < lodash < ramda\n\nramda被一些人认为强于lodash的一个重要的原因就是将柯里化的思想体现在api设计中。\n\n官方描述ramda的主要特性也说到，ramda就是为此设计的：\n\n>* Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.\n>* Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.\n>* The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.\n>\n>The last two points together make it very easy to build functions as sequences of simpler functions, each of which transforms the data and passes it along to the next. Ramda is designed to support this style of coding.\n\n## 什么是柯里化\n\n柯里化存在函数式编程中。在支持高阶函数（参数或返回值包含函数的函数）的语言里（如python，javascript），柯里化的产生是自然而然的。\n\n我们用实例来说明，观察以下python代码：\n\n```Python\na = map(lambda x: x*2, [1,2,3])\nb = map(lambda x: x*2, [4,5,6])\nc = map(lambda x: x*2, [7,8,9])\n```\n\n抽象是程序员的基本素养，上面的代码lambda函数多次使用，不够优雅切不易维护，我们会想到这样改进：\n\n```python\ndouble = lambda x: x*2\n\na = map(double, [1,2,3])\nb = map(double, [4,5,6])\nc = map(double, [7,8,9])\n```\n\n如此一来，当业务逻辑有变，我们只需要修改double变量。\n\n看上去已经足够了，但`map(double...`不够语义化，试想别人在解读这段代码的时候会这样想：\n\n“遍历这个list，将double函数作用在每一个元素上，返回一个新的list。”\n\n若不是double函数名已经足够语义化，我们还得翻看double函数的定义，看看它到底做了什么。是否可以再抽象一点，像下面这样调用： \n\n```python\na = getEachItemDoubled([1,2,3])\nb = getEachItemDoubled([4,5,6])\nc = getEachItemDoubled([7,8,9])\n```\n\n函数名清晰明确的表达了代码的意图，即使我们没有添加任何注释，谁都明白`getEachItemDoubled`做了什么。\n\n这样的`getEachItemDoubled`函数该怎么定义？\n\n考虑下面的代码。\n\n```Python\ndef curredMap(fn):\n    def p(x):\n        return map(fn, x)\n\treturn p\n\ngetEachItemDoubled = curredMap(lambda x:x*2)\n```\n\n**curredMap**和map一样也是个高阶函数，在这段代码中非常重要。如上，现在你可以用你希望的方式使用更语义的`getEachItemDoubled`。\n\n有了`curredMap`函数，你还可以这样：\n\n```python\n# 定义一个函数，用于将list每一个元素乘以3\ngetEachItemTripled = curredMap(lambda x: x*3)\n\n# 定义一个函数，用于将list每个元素字符串化\nstrEachItem = curredMap(lambda x: str(x))\n\na = getEachItemTripled([1,2,3]) # [3, 6, 9]\nb = strEachItem([1,2,3]) # ['1', '2', '3']\n```\n\n看到这你大概明白了，简而言之，柯里化就是函数的**局部调用**，也称**部分求值**，下面会进一步解释。\n\n## 柯里化的意义\n\n上面的例子中，我们对python的内置函数map做了**部分求值**得到了更加抽象的`getEachItemDoubled`、`getEachItemTripled`以及`strEachItem`，多参函数map变成了一些单参函数。\n\n原生map函数依赖两个参数，我们没有办法这样使用：\n\n```python\ngetEachItemDoubled = map(lambda x:x*2)\n# TypeError: map() requires at least two args\n```\n\n编译器会抛出TypeError错误。 这样的设计在初学者看来非常痛苦，我需要记住每一个函数必须传递几个参数吗？\n\n把最初的代码和最终柯里化后的代码放到一起：\n\n```\na = map(lambda x: x*2, [1,2,3])\n\na = curredMap(lambda x: x*2)([1,2,3])\n```\n\nmap被我们做了降阶处理，这样做有什么意义？\n\n就上面的例子而言。\n\n* 可读性更强。\n\n\n* 接口简化。\n* 复用性更高。\n\n最重要的是：你不需要在脑海里记住map函数必须传递两个参数，尽管放心使用`curredMap`。\n\n我们现在可以这么理解**局部调用**：map函数要求两个参数，但我只给了它一个参数，理应返回一个能够接收第二个参数的函数，无论我何时想要传递第二个参数，它都能正常工作。这就是柯里化出现的意义。\n\n再用一段js代码来说明。\n\n```Javascript\nfunction sum(a, b){\n  return a + b\n}\n\n\nfunction cu(x, y){\n  function fn(z){\n    return x + z\n  }\n  if(arguments.length === 1){\n    return fn\n  } \n  return x + y  \n}\n\nsum(1,2)\ncurredSum(1)(2)\n```\n\ncurredSum看上去并没有比sum函数可读性更好，也不见得接口更简单，两者似乎没什么区别。\n\n而curredSum的真正优势体现在下面这种情形中。\n\n```javascript\n/* 方式一 */\nsum(1,2,3,4)\nsum(1,2,3,7)\nsum(1,2,3,11,12)\nsum(1,2,3,11,12,14)\nsum(1,2,3,11,12,17)\n// ...\n\n/* 方式二 */\nvar sixPlus = curredSum(1+2+3)\nsixPlus(4)\nsixPlus(7)\nsixPlus(11)\nvar twentyNinePlus = curredSum(1+2+3+11+12)\ntwentyNinePlus(14)\ntwentyNinePlus(17)\n// ...\n```\n\n若参数被多次复用，就应该抽象出来，无论怎么看，柯里化后的代码都更加容易维护和扩展，并且也不失易读性。\n\n最后，我们来看看ramda中的柯里化。\n\n```javascript\nvar R = require('ramda')\n\nR.append('c', ['a','b']) // -> ['a','b','c']\n/* 下面的函数作用是为数组追加一个'c' */\nvar appendC = R.append('c')\nappendC(['a','b']) // -> ['a','b','c']\nappendC([1,2,3]) // -> [1,2,3,'c']\n\nR.remove(1,2,[1,2,3,4,5]) // -> [1,4]\n/* 下面这个函数的作用是从[1,2,3,4,5]开始位置去除x个数，返回一个新的数组 */\n/* R.__在这里作为占位符，表示柯里化后的函数形参应该传递的位置 */\nvar removeXFromStart = R.remove(0,R.__,[1,2,3,4,5])\nremoveXFromStart(2) // -> [3,4,5]\nremoveXFromStart(4) // -> [5]\n\n/* 下面这个更复杂一点 */\n/* t函数的作用是取出参数的x属性值，乘2，取反 */\nvar t = R.compose(R.negate, x => x*2, R.prop('x'))\nt({\n  x: 100,\n  y: 200,\n  z: 300\n}) // -> -200\nt({\n  x: 1,\n  y: 2\n}) // -> -2\n```\n\n如果你用过lodash，你一定清楚上面的例子和lodash的区别，但lodash用户是否应该为此就过渡到ramda，推荐你看看Scott Sauyet写的[why ramda](http://fr.umio.us/why-ramda/)，以及google一下ramda和lodash的更多对比再做决定。\n\n尽管以上说的都是柯里化为函数式编程带来的好处，我还是得说，理智的程序员还是应该谨慎使用这种编程方法。\n\n不该使用柯里化的场景之一是：函数的参数总是需要多个同时传递，否则函数本身的语义就不明确，或者被破坏。例如一个函数定义为标出地图上的点，往往在使用它的时候经度和纬度会同时传入，无论你只传入经度还是纬度都显得很别扭，柯里化这样的函数没有意义，纯粹画蛇添足。\n\n另外，我们应该思考，既然柯里化让一切那么美好，很多语言设计之初为什么让函数可以定义多个形参，为什么在这之上更衍生出了默认参数、可变参数、关键字参数？参数定义如此灵活是好是坏？\n\npython由于tuple这种数据类型的存在，使得多参函数轻易的接受一个混合过后的tuple作为参数，并将其展开为多个参数，仿佛函数定义时的参数个数毫无约束性，多参函数仍然可以像单参函数一样使用，考量一个函数应该定义多参还是单参在python里似乎并不重要了，个人爱好这时候高于一切。仍然有很多使用多参函数的场景，大多数人可以熟练的将参数提前组合，柯里化只不过把步骤分解了。\n\n在我看来，应不应该柯里化，只需考量一点，局部调用这个函数是否意义更明确。\n\n强行柯里化也可能是灾难。\n","slug":"柯里化的意义","published":1,"updated":"2016-11-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eoll00054n9kvzjc5een","content":"<p>最近某个技术群中有人激进的表达绝不用<strong>lodash</strong>，称lodash作者态度傲慢，自己只用<strong>ramda</strong>，于是我很好奇，研究了一会ramda，引申出下面的思考。</p>\n<p>粗略看ramda官方文档不会觉得与lodash有什么不同，但实际上这两者的设计理念很不一样，如果把另一个著名的类库underscore也放到一起对比，大多数人的看法是这样的：</p>\n<blockquote>\n<p>underscore &lt; lodash &lt; ramda</p>\n</blockquote>\n<p>ramda被一些人认为强于lodash的一个重要的原因就是将柯里化的思想体现在api设计中。</p>\n<p>官方描述ramda的主要特性也说到，ramda就是为此设计的：</p>\n<blockquote>\n<ul>\n<li>Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.</li>\n<li>Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.</li>\n<li>The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.</li>\n</ul>\n<p>The last two points together make it very easy to build functions as sequences of simpler functions, each of which transforms the data and passes it along to the next. Ramda is designed to support this style of coding.</p>\n</blockquote>\n<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>柯里化存在函数式编程中。在支持高阶函数（参数或返回值包含函数的函数）的语言里（如python，javascript），柯里化的产生是自然而然的。</p>\n<p>我们用实例来说明，观察以下python代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>抽象是程序员的基本素养，上面的代码lambda函数多次使用，不够优雅切不易维护，我们会想到这样改进：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">double = <span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">a = map(double, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = map(double, [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = map(double, [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>如此一来，当业务逻辑有变，我们只需要修改double变量。</p>\n<p>看上去已经足够了，但<code>map(double...</code>不够语义化，试想别人在解读这段代码的时候会这样想：</p>\n<p>“遍历这个list，将double函数作用在每一个元素上，返回一个新的list。”</p>\n<p>若不是double函数名已经足够语义化，我们还得翻看double函数的定义，看看它到底做了什么。是否可以再抽象一点，像下面这样调用： </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = getEachItemDoubled([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = getEachItemDoubled([<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = getEachItemDoubled([<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>函数名清晰明确的表达了代码的意图，即使我们没有添加任何注释，谁都明白<code>getEachItemDoubled</code>做了什么。</p>\n<p>这样的<code>getEachItemDoubled</code>函数该怎么定义？</p>\n<p>考虑下面的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curredMap</span><span class=\"params\">(fn)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">p</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> map(fn, x)</div><div class=\"line\">\t<span class=\"keyword\">return</span> p</div><div class=\"line\"></div><div class=\"line\">getEachItemDoubled = curredMap(<span class=\"keyword\">lambda</span> x:x*<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p><strong>curredMap</strong>和map一样也是个高阶函数，在这段代码中非常重要。如上，现在你可以用你希望的方式使用更语义的<code>getEachItemDoubled</code>。</p>\n<p>有了<code>curredMap</code>函数，你还可以这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义一个函数，用于将list每一个元素乘以3</span></div><div class=\"line\">getEachItemTripled = curredMap(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 定义一个函数，用于将list每个元素字符串化</span></div><div class=\"line\">strEachItem = curredMap(<span class=\"keyword\">lambda</span> x: str(x))</div><div class=\"line\"></div><div class=\"line\">a = getEachItemTripled([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># [3, 6, 9]</span></div><div class=\"line\">b = strEachItem([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># ['1', '2', '3']</span></div></pre></td></tr></table></figure>\n<p>看到这你大概明白了，简而言之，柯里化就是函数的<strong>局部调用</strong>，也称<strong>部分求值</strong>，下面会进一步解释。</p>\n<h2 id=\"柯里化的意义\"><a href=\"#柯里化的意义\" class=\"headerlink\" title=\"柯里化的意义\"></a>柯里化的意义</h2><p>上面的例子中，我们对python的内置函数map做了<strong>部分求值</strong>得到了更加抽象的<code>getEachItemDoubled</code>、<code>getEachItemTripled</code>以及<code>strEachItem</code>，多参函数map变成了一些单参函数。</p>\n<p>原生map函数依赖两个参数，我们没有办法这样使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">getEachItemDoubled = map(<span class=\"keyword\">lambda</span> x:x*<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\"># TypeError: map() requires at least two args</span></div></pre></td></tr></table></figure>\n<p>编译器会抛出TypeError错误。 这样的设计在初学者看来非常痛苦，我需要记住每一个函数必须传递几个参数吗？</p>\n<p>把最初的代码和最终柯里化后的代码放到一起：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = map(lambda x: x*2, [1,2,3])</div><div class=\"line\"></div><div class=\"line\">a = curredMap(lambda x: x*2)([1,2,3])</div></pre></td></tr></table></figure>\n<p>map被我们做了降阶处理，这样做有什么意义？</p>\n<p>就上面的例子而言。</p>\n<ul>\n<li>可读性更强。</li>\n</ul>\n<ul>\n<li>接口简化。</li>\n<li>复用性更高。</li>\n</ul>\n<p>最重要的是：你不需要在脑海里记住map函数必须传递两个参数，尽管放心使用<code>curredMap</code>。</p>\n<p>我们现在可以这么理解<strong>局部调用</strong>：map函数要求两个参数，但我只给了它一个参数，理应返回一个能够接收第二个参数的函数，无论我何时想要传递第二个参数，它都能正常工作。这就是柯里化出现的意义。</p>\n<p>再用一段js代码来说明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cu</span>(<span class=\"params\">x, y</span>)</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">z</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + z</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">return</span> x + y  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</div><div class=\"line\">curredSum(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>curredSum看上去并没有比sum函数可读性更好，也不见得接口更简单，两者似乎没什么区别。</p>\n<p>而curredSum的真正优势体现在下面这种情形中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 方式一 */</span></div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">14</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">17</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 方式二 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> sixPlus = curredSum(<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">4</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">7</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">11</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> twentyNinePlus = curredSum(<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">11</span>+<span class=\"number\">12</span>)</div><div class=\"line\">twentyNinePlus(<span class=\"number\">14</span>)</div><div class=\"line\">twentyNinePlus(<span class=\"number\">17</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<p>若参数被多次复用，就应该抽象出来，无论怎么看，柯里化后的代码都更加容易维护和扩展，并且也不失易读性。</p>\n<p>最后，我们来看看ramda中的柯里化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>)</div><div class=\"line\"></div><div class=\"line\">R.append(<span class=\"string\">'c'</span>, [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]) <span class=\"comment\">// -&gt; ['a','b','c']</span></div><div class=\"line\"><span class=\"comment\">/* 下面的函数作用是为数组追加一个'c' */</span></div><div class=\"line\"><span class=\"keyword\">var</span> appendC = R.append(<span class=\"string\">'c'</span>)</div><div class=\"line\">appendC([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]) <span class=\"comment\">// -&gt; ['a','b','c']</span></div><div class=\"line\">appendC([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">// -&gt; [1,2,3,'c']</span></div><div class=\"line\"></div><div class=\"line\">R.remove(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">// -&gt; [1,4]</span></div><div class=\"line\"><span class=\"comment\">/* 下面这个函数的作用是从[1,2,3,4,5]开始位置去除x个数，返回一个新的数组 */</span></div><div class=\"line\"><span class=\"comment\">/* R.__在这里作为占位符，表示柯里化后的函数形参应该传递的位置 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> removeXFromStart = R.remove(<span class=\"number\">0</span>,R.__,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>])</div><div class=\"line\">removeXFromStart(<span class=\"number\">2</span>) <span class=\"comment\">// -&gt; [3,4,5]</span></div><div class=\"line\">removeXFromStart(<span class=\"number\">4</span>) <span class=\"comment\">// -&gt; [5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 下面这个更复杂一点 */</span></div><div class=\"line\"><span class=\"comment\">/* t函数的作用是取出参数的x属性值，乘2，取反 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = R.compose(R.negate, x =&gt; x*<span class=\"number\">2</span>, R.prop(<span class=\"string\">'x'</span>))</div><div class=\"line\">t(&#123;</div><div class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">100</span>,</div><div class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"attr\">z</span>: <span class=\"number\">300</span></div><div class=\"line\">&#125;) <span class=\"comment\">// -&gt; -200</span></div><div class=\"line\">t(&#123;</div><div class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">2</span></div><div class=\"line\">&#125;) <span class=\"comment\">// -&gt; -2</span></div></pre></td></tr></table></figure>\n<p>如果你用过lodash，你一定清楚上面的例子和lodash的区别，但lodash用户是否应该为此就过渡到ramda，推荐你看看Scott Sauyet写的<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"external\">why ramda</a>，以及google一下ramda和lodash的更多对比再做决定。</p>\n<p>尽管以上说的都是柯里化为函数式编程带来的好处，我还是得说，理智的程序员还是应该谨慎使用这种编程方法。</p>\n<p>不该使用柯里化的场景之一是：函数的参数总是需要多个同时传递，否则函数本身的语义就不明确，或者被破坏。例如一个函数定义为标出地图上的点，往往在使用它的时候经度和纬度会同时传入，无论你只传入经度还是纬度都显得很别扭，柯里化这样的函数没有意义，纯粹画蛇添足。</p>\n<p>另外，我们应该思考，既然柯里化让一切那么美好，很多语言设计之初为什么让函数可以定义多个形参，为什么在这之上更衍生出了默认参数、可变参数、关键字参数？参数定义如此灵活是好是坏？</p>\n<p>python由于tuple这种数据类型的存在，使得多参函数轻易的接受一个混合过后的tuple作为参数，并将其展开为多个参数，仿佛函数定义时的参数个数毫无约束性，多参函数仍然可以像单参函数一样使用，考量一个函数应该定义多参还是单参在python里似乎并不重要了，个人爱好这时候高于一切。仍然有很多使用多参函数的场景，大多数人可以熟练的将参数提前组合，柯里化只不过把步骤分解了。</p>\n<p>在我看来，应不应该柯里化，只需考量一点，局部调用这个函数是否意义更明确。</p>\n<p>强行柯里化也可能是灾难。</p>\n","excerpt":"","more":"<p>最近某个技术群中有人激进的表达绝不用<strong>lodash</strong>，称lodash作者态度傲慢，自己只用<strong>ramda</strong>，于是我很好奇，研究了一会ramda，引申出下面的思考。</p>\n<p>粗略看ramda官方文档不会觉得与lodash有什么不同，但实际上这两者的设计理念很不一样，如果把另一个著名的类库underscore也放到一起对比，大多数人的看法是这样的：</p>\n<blockquote>\n<p>underscore &lt; lodash &lt; ramda</p>\n</blockquote>\n<p>ramda被一些人认为强于lodash的一个重要的原因就是将柯里化的思想体现在api设计中。</p>\n<p>官方描述ramda的主要特性也说到，ramda就是为此设计的：</p>\n<blockquote>\n<ul>\n<li>Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.</li>\n<li>Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.</li>\n<li>The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.</li>\n</ul>\n<p>The last two points together make it very easy to build functions as sequences of simpler functions, each of which transforms the data and passes it along to the next. Ramda is designed to support this style of coding.</p>\n</blockquote>\n<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>柯里化存在函数式编程中。在支持高阶函数（参数或返回值包含函数的函数）的语言里（如python，javascript），柯里化的产生是自然而然的。</p>\n<p>我们用实例来说明，观察以下python代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span>, [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>抽象是程序员的基本素养，上面的代码lambda函数多次使用，不够优雅切不易维护，我们会想到这样改进：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">double = <span class=\"keyword\">lambda</span> x: x*<span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">a = map(double, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = map(double, [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = map(double, [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>如此一来，当业务逻辑有变，我们只需要修改double变量。</p>\n<p>看上去已经足够了，但<code>map(double...</code>不够语义化，试想别人在解读这段代码的时候会这样想：</p>\n<p>“遍历这个list，将double函数作用在每一个元素上，返回一个新的list。”</p>\n<p>若不是double函数名已经足够语义化，我们还得翻看double函数的定义，看看它到底做了什么。是否可以再抽象一点，像下面这样调用： </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = getEachItemDoubled([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</div><div class=\"line\">b = getEachItemDoubled([<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div><div class=\"line\">c = getEachItemDoubled([<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</div></pre></td></tr></table></figure>\n<p>函数名清晰明确的表达了代码的意图，即使我们没有添加任何注释，谁都明白<code>getEachItemDoubled</code>做了什么。</p>\n<p>这样的<code>getEachItemDoubled</code>函数该怎么定义？</p>\n<p>考虑下面的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curredMap</span><span class=\"params\">(fn)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">p</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> map(fn, x)</div><div class=\"line\">\t<span class=\"keyword\">return</span> p</div><div class=\"line\"></div><div class=\"line\">getEachItemDoubled = curredMap(<span class=\"keyword\">lambda</span> x:x*<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p><strong>curredMap</strong>和map一样也是个高阶函数，在这段代码中非常重要。如上，现在你可以用你希望的方式使用更语义的<code>getEachItemDoubled</code>。</p>\n<p>有了<code>curredMap</code>函数，你还可以这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义一个函数，用于将list每一个元素乘以3</span></div><div class=\"line\">getEachItemTripled = curredMap(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 定义一个函数，用于将list每个元素字符串化</span></div><div class=\"line\">strEachItem = curredMap(<span class=\"keyword\">lambda</span> x: str(x))</div><div class=\"line\"></div><div class=\"line\">a = getEachItemTripled([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># [3, 6, 9]</span></div><div class=\"line\">b = strEachItem([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># ['1', '2', '3']</span></div></pre></td></tr></table></figure>\n<p>看到这你大概明白了，简而言之，柯里化就是函数的<strong>局部调用</strong>，也称<strong>部分求值</strong>，下面会进一步解释。</p>\n<h2 id=\"柯里化的意义\"><a href=\"#柯里化的意义\" class=\"headerlink\" title=\"柯里化的意义\"></a>柯里化的意义</h2><p>上面的例子中，我们对python的内置函数map做了<strong>部分求值</strong>得到了更加抽象的<code>getEachItemDoubled</code>、<code>getEachItemTripled</code>以及<code>strEachItem</code>，多参函数map变成了一些单参函数。</p>\n<p>原生map函数依赖两个参数，我们没有办法这样使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">getEachItemDoubled = map(<span class=\"keyword\">lambda</span> x:x*<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\"># TypeError: map() requires at least two args</span></div></pre></td></tr></table></figure>\n<p>编译器会抛出TypeError错误。 这样的设计在初学者看来非常痛苦，我需要记住每一个函数必须传递几个参数吗？</p>\n<p>把最初的代码和最终柯里化后的代码放到一起：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = map(lambda x: x*2, [1,2,3])</div><div class=\"line\"></div><div class=\"line\">a = curredMap(lambda x: x*2)([1,2,3])</div></pre></td></tr></table></figure>\n<p>map被我们做了降阶处理，这样做有什么意义？</p>\n<p>就上面的例子而言。</p>\n<ul>\n<li>可读性更强。</li>\n</ul>\n<ul>\n<li>接口简化。</li>\n<li>复用性更高。</li>\n</ul>\n<p>最重要的是：你不需要在脑海里记住map函数必须传递两个参数，尽管放心使用<code>curredMap</code>。</p>\n<p>我们现在可以这么理解<strong>局部调用</strong>：map函数要求两个参数，但我只给了它一个参数，理应返回一个能够接收第二个参数的函数，无论我何时想要传递第二个参数，它都能正常工作。这就是柯里化出现的意义。</p>\n<p>再用一段js代码来说明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cu</span>(<span class=\"params\">x, y</span>)</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">z</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + z</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">return</span> x + y  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</div><div class=\"line\">curredSum(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>curredSum看上去并没有比sum函数可读性更好，也不见得接口更简单，两者似乎没什么区别。</p>\n<p>而curredSum的真正优势体现在下面这种情形中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 方式一 */</span></div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">14</span>)</div><div class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">17</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 方式二 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> sixPlus = curredSum(<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">4</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">7</span>)</div><div class=\"line\">sixPlus(<span class=\"number\">11</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> twentyNinePlus = curredSum(<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">11</span>+<span class=\"number\">12</span>)</div><div class=\"line\">twentyNinePlus(<span class=\"number\">14</span>)</div><div class=\"line\">twentyNinePlus(<span class=\"number\">17</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<p>若参数被多次复用，就应该抽象出来，无论怎么看，柯里化后的代码都更加容易维护和扩展，并且也不失易读性。</p>\n<p>最后，我们来看看ramda中的柯里化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>)</div><div class=\"line\"></div><div class=\"line\">R.append(<span class=\"string\">'c'</span>, [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]) <span class=\"comment\">// -&gt; ['a','b','c']</span></div><div class=\"line\"><span class=\"comment\">/* 下面的函数作用是为数组追加一个'c' */</span></div><div class=\"line\"><span class=\"keyword\">var</span> appendC = R.append(<span class=\"string\">'c'</span>)</div><div class=\"line\">appendC([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]) <span class=\"comment\">// -&gt; ['a','b','c']</span></div><div class=\"line\">appendC([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">// -&gt; [1,2,3,'c']</span></div><div class=\"line\"></div><div class=\"line\">R.remove(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">// -&gt; [1,4]</span></div><div class=\"line\"><span class=\"comment\">/* 下面这个函数的作用是从[1,2,3,4,5]开始位置去除x个数，返回一个新的数组 */</span></div><div class=\"line\"><span class=\"comment\">/* R.__在这里作为占位符，表示柯里化后的函数形参应该传递的位置 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> removeXFromStart = R.remove(<span class=\"number\">0</span>,R.__,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>])</div><div class=\"line\">removeXFromStart(<span class=\"number\">2</span>) <span class=\"comment\">// -&gt; [3,4,5]</span></div><div class=\"line\">removeXFromStart(<span class=\"number\">4</span>) <span class=\"comment\">// -&gt; [5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 下面这个更复杂一点 */</span></div><div class=\"line\"><span class=\"comment\">/* t函数的作用是取出参数的x属性值，乘2，取反 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = R.compose(R.negate, x =&gt; x*<span class=\"number\">2</span>, R.prop(<span class=\"string\">'x'</span>))</div><div class=\"line\">t(&#123;</div><div class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">100</span>,</div><div class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"attr\">z</span>: <span class=\"number\">300</span></div><div class=\"line\">&#125;) <span class=\"comment\">// -&gt; -200</span></div><div class=\"line\">t(&#123;</div><div class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">2</span></div><div class=\"line\">&#125;) <span class=\"comment\">// -&gt; -2</span></div></pre></td></tr></table></figure>\n<p>如果你用过lodash，你一定清楚上面的例子和lodash的区别，但lodash用户是否应该为此就过渡到ramda，推荐你看看Scott Sauyet写的<a href=\"http://fr.umio.us/why-ramda/\">why ramda</a>，以及google一下ramda和lodash的更多对比再做决定。</p>\n<p>尽管以上说的都是柯里化为函数式编程带来的好处，我还是得说，理智的程序员还是应该谨慎使用这种编程方法。</p>\n<p>不该使用柯里化的场景之一是：函数的参数总是需要多个同时传递，否则函数本身的语义就不明确，或者被破坏。例如一个函数定义为标出地图上的点，往往在使用它的时候经度和纬度会同时传入，无论你只传入经度还是纬度都显得很别扭，柯里化这样的函数没有意义，纯粹画蛇添足。</p>\n<p>另外，我们应该思考，既然柯里化让一切那么美好，很多语言设计之初为什么让函数可以定义多个形参，为什么在这之上更衍生出了默认参数、可变参数、关键字参数？参数定义如此灵活是好是坏？</p>\n<p>python由于tuple这种数据类型的存在，使得多参函数轻易的接受一个混合过后的tuple作为参数，并将其展开为多个参数，仿佛函数定义时的参数个数毫无约束性，多参函数仍然可以像单参函数一样使用，考量一个函数应该定义多参还是单参在python里似乎并不重要了，个人爱好这时候高于一切。仍然有很多使用多参函数的场景，大多数人可以熟练的将参数提前组合，柯里化只不过把步骤分解了。</p>\n<p>在我看来，应不应该柯里化，只需考量一点，局部调用这个函数是否意义更明确。</p>\n<p>强行柯里化也可能是灾难。</p>\n"},{"title":"什么是模块","date":"2016-11-07T00:48:32.000Z","_content":"\n### 写在前面\n\n阅读下文假定你基本了解：使用`mocha`做单元测试，angularjs，nodejs环境搭建以及npm的使用。\n\n先说结论：\n\n* 被函数包装，每次调用实例化一个新的对象或返回同一个对象（单例模式下，函数至少需要调用一次）\n\n* 上述函数中有内部函数暴露出来，使其内部作用域形成闭包。\n\n\nAngularjs是个很'模块化'的框架，这里不谈MVC，MVVM，指令，服务。谈谈ng中的依赖注入，ng出世时最为人称道的概念之一。\n\n基于上述结论我会写个模块构造器，以这个例子来说明如何创建一个模块。\n\n以下ng指代angular。\n\n### ng中的依赖注入\n\n在ng中，当我们要创建一个不依赖任何模块的模块`foo`，我们这样写：\n\n```javascript\nangular.module('foo', [])\n```\n\n当我们要创建另一个依赖上述`foo`模块的另一个模块时我们这样写：\n\n```javascript\nangular.module('another', ['foo'])\n```\n\n这就是最简单的依赖注入。\n\n在第一个`foo`模块中，由于angular的module方法返回angular自身，我们可以像jQuery那样链式调用，在其后创建模块中的`service`，就像下面这样：\n\n```javascript\nangular.module('foo', []).service('fooService', [function($scope){}])\n```\n\n当`another`声明自己依赖`foo`时，`foo`中的service**注入**了`another`，在这个过程中，angular帮助我们完成了篇头的**结论一**，模块`another`接着创建controller时可以使用foo中已经创建好的service：\n\n```javascript\nangular.module('another', ['foo']).controller('anotherCtrl', ['fooService', function(fooService){}])\n```\n\n我们注意到一个细节，controller方法的第二个参数是一个数组，数组的第一个元素声明了所依赖的模块名，而数组的最后一个元素是个匿名函数，`fooService`在这里被当做参数**注入**了，显然，在这个匿名函数里你可以调用fooService实例化后暴露的公共api，访问到到原始fooService里的私有变量，js程序员不可能不知道，这就是**闭包**。\n\n### 我们的模块\n\nng里的controller，service等可以视为子模块，简单起见，我们的模块去掉了这些概念，但保留了依赖注入：\n\n```javascript\nMyModule.module('module1', [], function(){})\n\nMyModule.module('module2', ['module1'], function(module1){})\n\nMyModule.module('module3', ['module1', 'module2'], function(module1, module2){})\n```\n\n上面的代码中，`MyModule`定义了三个模块，module1不依赖任何模块，module2依赖module1，module3依赖module1和module2。\n\n为了实现上述的模式，我们来先写一点测试。\n\n创建一个空项目目录，在根目录创建test文件夹，并且在test文件夹内创建module.js文件，下面是module.js文件的内容：\n\n```Javascript\nlet expect = require('chai').expect;\n\ndescribe('My module tests', function() {\n\tlet MyModule;\n\n\tbefore(function(done) {\n\t\tMyModule = require('../index.js')()\n\n\t\tdone()\n\t})\n\n\tit('desc MyModule', function(){\n\t\texpect(MyModule).has.a.property('module')\n\t\texpect(MyModule).has.a.property('getAll')\n\t})\n})\n```\n\n在测试代码里我们指明了模块构造器的路径（根目录的index.js），它提供了两个方法，`module`和`getAll`，顾名思义，`module`方法定义模块，`getAll`方法获得所有模块。\n\n先来创建`index.js`，使最开始的测试代码通过：\n\n```javascript\nexports = module.exports = function() {\n\treturn {\n\t\tmodule: function() {\n\n\t\t},\n\t\tgetAll: function() {\n\n\t\t}\n\t}\n}\n```\n\n运行`mocha`，一片绿灯。\n\n现在可以定义我们的第一个模块了，在测试代码中添加以下内容：\n\n```javascript\nit('define module1', function() {\n\tMyModule.module('module1', [], function() {\n\t\t\tlet tmp = 123\n\t\t\treturn {\n\t\t\t\tfoo: tmp\n\t\t\t}\n\t})\n\n\texpect(MyModule.getAll()).has.a.property('module1')\n})\n```\n\nmodule1不依赖任何模块，所以第二个参数是个空数组，第三个参数定义了module1作为模块被注入其它模块时提供了什么，注意到这个函数中有个私有变量tmp，为了证明稍后这里形成了闭包，我们把暴露出去的foo属性指向了tmp，稍后在module2中我们会尝试访问它。\n\n现在运行测试代码，当然不会通过，我们来为这段测试脚本更新index.js。\n\n```javascript\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\n内部的私有变量modules是个哈希列表，因为模块名是**唯一的不重名的字符串**，我们自然的想到用这样的数据结构储存它，module方法简单的把模块和相关信息放到了modules里，而getAll方法则直接返回了modules。\n\n这样，我们通过了第二段测试。\n\n继续往下，在测试代码中定义第二个模块：\n\n```javascript\nit('define module2', function() {\n\tMyModule.module('module2', ['module1'], function(module1) {\n\t\texpect(module1.foo).to.equal(123)\n\t\treturn {\n\t\t\ta: 456,\n\t\t\tref: module1\n\t\t}\n\t})\n\texpect(MyModule.getAll()).has.a.property('module2')\n})\n```\n\nmodule1被注入到了module2中，并且在module2里我们尝试访问module1的foo属性，如果一切顺利，它应该是`123`。\n\n实现上面的逻辑我们需要对MyModule的module方法里的第二个参数做一些处理，现在来修改index.js：\n\n```Javascript\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tfunction enumerateInjects(injects) {\n\t\t\t\tlet tmp = [];\n\n\t\t\t\tfor (let i in injects) {\n\t\t\t\t\tif (modules[injects[i]]) {\n\t\t\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\n\t\t\tbody.apply(this, enumerateInjects(injects))\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\nenumerateInjects函数遍历了injects参数，把对应模块执行，并将执行后的结果放到一个数组里返回，并且我们还额外做了一点错误处理（当指定要依赖的模块不存在时抛出错误）。在module方法的最后，我们把得到的数组传给了body函数，apply方法在这里很关键，第二个参数数组被展开成了多个参数，于是module2拿到了module1执行后的结果。\n\n此时再运行一遍测试脚本，比预料的还要顺利。\n\n看上去我们的构造器完成了，module1顺利注入到了module2里，实际上到此为止module1确实构成了一个模块，可以被注入到任何模块中。但我们考虑的还不够，我们应该继续往下，尝试构造module3，把module1和module2都注入进去看看会发生什么。\n\n补充测试脚本：\n\n```javascript\nit('define module3', function() {\n\tMyModule.module('module3', ['module1', 'module2'], function(module1, module2) {\n\t\texpect(module1.foo).to.equal(123)\n\t\texpect(module2.a).to.equal(456)\n\t\texpect(module2.ref.foo).to.equal(123)\n\n\t})\n\n\texpect(MyModule.getAll()).has.a.property('module3')\n})\n```\n\n再次运行测试，没有通过。控制台抛出了TypeError错误，告诉我们这里引用了不存在的属性。\n\n思考index.js里的代码，我们假定module1的注入没有问题（事实上确实没问题，因为前面已经经过检验），当我们把module2注入module3时enumerateInjects函数做了什么？\n\nmodule2依赖module1，但遍历过程中我们却忽略了这一点，直接执行module2的body而不考虑它在定义时声明的依赖，若module1此时没有注入到module2里，自然不可能得到我们预期的结果。\n\n对enumerateInjects函数做如下修改：\n\n```Javascript\nfunction enumerateInjects(injects) {\n\tlet tmp = [];\n    for (let i in injects) {\n\t\tif (modules[injects[i]]) {\n\t\t\tif (modules[injects[i]].dependencies.length > 0) {\n\t\t\t\tlet deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);\n\n\t\t\t\ttmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))\n\t\t\t} else {\n\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n        }\n\t}\n\n\treturn tmp;\n}\n```\n\n在第一个if判断里我们添加了对依赖的依赖的依赖…的处理，没错，这是个**递归**，无论模块嵌套有多深，在有限的深度里我们都可以将它一个个找到并最终传递给当前模块。\n\n到此，测试脚本顺利运行。最终我们的module.js和index.js如下：\n\n```Javascript\n// module.js\nlet expect = require('chai').expect;\n\ndescribe('My module tests', function() {\n\tlet MyModule;\n\n\tbefore(function(done) {\n\t\tMyModule = require('../index.js')()\n\n\t\tdone()\n\t})\n\n\tit('desc MyModule', function() {\n\t\texpect(MyModule).has.a.property('module')\n\t\texpect(MyModule).has.a.property('getAll')\n\t})\n\n\tit('define module1', function() {\n\t\tMyModule.module('module1', [], function() {\n\t\t\tlet tmp = 123\n\t\t\treturn {\n\t\t\t\tfoo: tmp\n\t\t\t}\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module1')\n\t})\n\n\tit('define module2', function() {\n\t\tMyModule.module('module2', ['module1'], function(module1) {\n\t\t\texpect(module1.foo).to.equal(123)\n\n\t\t\treturn {\n\t\t\t\ta: 456,\n\t\t\t\tref: module1\n\t\t\t}\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module2')\n\t})\n\n\tit('define module3', function() {\n\t\tMyModule.module('module3', ['module1', 'module2'], function(module1, module2) {\n\t\t\texpect(module1.foo).to.equal(123)\n\t\t\texpect(module2.a).to.equal(456)\n\t\t\texpect(module2.ref.foo).to.equal(123)\n\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module3')\n\t})\n\n})\n```\n\n```Javascript\n// index.js\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tfunction enumerateInjects(injects) {\n\t\t\t\tlet tmp = [];\n\t\t\t\tfor (let i in injects) {\n\t\t\t\t\tif (modules[injects[i]]) {\n\t\t\t\t\t\tif (modules[injects[i]].dependencies.length > 0) {\n\t\t\t\t\t\t\tlet deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);\n\n\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\n\t\t\tbody.apply(this, enumerateInjects(injects))\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\n本文的最后，我们定义的module3其实并不是一个模块，因为它没有满足篇头结论里的第二条。因此在别的模块中注入它是毫无意义的。\n\n良好的模块定义和管理在协作开发中至关重要，模块模式并没有什么最佳实践，有的只是对经验的不段总结，本文说述的也只是模块模式的凤毛麟角。\n\n本篇文章里的代码不建议用到生产环境中，建议使用优秀的方案如[require.js](https://github.com/requirejs/requirejs)。\n\n完整源码地址：[github](https://github.com/cyyyu/inc)\n\n","source":"_posts/什么是模块.md","raw":"---\ntitle: 什么是模块\ndate: 2016-11-07 08:48:32\ntags:\n---\n\n### 写在前面\n\n阅读下文假定你基本了解：使用`mocha`做单元测试，angularjs，nodejs环境搭建以及npm的使用。\n\n先说结论：\n\n* 被函数包装，每次调用实例化一个新的对象或返回同一个对象（单例模式下，函数至少需要调用一次）\n\n* 上述函数中有内部函数暴露出来，使其内部作用域形成闭包。\n\n\nAngularjs是个很'模块化'的框架，这里不谈MVC，MVVM，指令，服务。谈谈ng中的依赖注入，ng出世时最为人称道的概念之一。\n\n基于上述结论我会写个模块构造器，以这个例子来说明如何创建一个模块。\n\n以下ng指代angular。\n\n### ng中的依赖注入\n\n在ng中，当我们要创建一个不依赖任何模块的模块`foo`，我们这样写：\n\n```javascript\nangular.module('foo', [])\n```\n\n当我们要创建另一个依赖上述`foo`模块的另一个模块时我们这样写：\n\n```javascript\nangular.module('another', ['foo'])\n```\n\n这就是最简单的依赖注入。\n\n在第一个`foo`模块中，由于angular的module方法返回angular自身，我们可以像jQuery那样链式调用，在其后创建模块中的`service`，就像下面这样：\n\n```javascript\nangular.module('foo', []).service('fooService', [function($scope){}])\n```\n\n当`another`声明自己依赖`foo`时，`foo`中的service**注入**了`another`，在这个过程中，angular帮助我们完成了篇头的**结论一**，模块`another`接着创建controller时可以使用foo中已经创建好的service：\n\n```javascript\nangular.module('another', ['foo']).controller('anotherCtrl', ['fooService', function(fooService){}])\n```\n\n我们注意到一个细节，controller方法的第二个参数是一个数组，数组的第一个元素声明了所依赖的模块名，而数组的最后一个元素是个匿名函数，`fooService`在这里被当做参数**注入**了，显然，在这个匿名函数里你可以调用fooService实例化后暴露的公共api，访问到到原始fooService里的私有变量，js程序员不可能不知道，这就是**闭包**。\n\n### 我们的模块\n\nng里的controller，service等可以视为子模块，简单起见，我们的模块去掉了这些概念，但保留了依赖注入：\n\n```javascript\nMyModule.module('module1', [], function(){})\n\nMyModule.module('module2', ['module1'], function(module1){})\n\nMyModule.module('module3', ['module1', 'module2'], function(module1, module2){})\n```\n\n上面的代码中，`MyModule`定义了三个模块，module1不依赖任何模块，module2依赖module1，module3依赖module1和module2。\n\n为了实现上述的模式，我们来先写一点测试。\n\n创建一个空项目目录，在根目录创建test文件夹，并且在test文件夹内创建module.js文件，下面是module.js文件的内容：\n\n```Javascript\nlet expect = require('chai').expect;\n\ndescribe('My module tests', function() {\n\tlet MyModule;\n\n\tbefore(function(done) {\n\t\tMyModule = require('../index.js')()\n\n\t\tdone()\n\t})\n\n\tit('desc MyModule', function(){\n\t\texpect(MyModule).has.a.property('module')\n\t\texpect(MyModule).has.a.property('getAll')\n\t})\n})\n```\n\n在测试代码里我们指明了模块构造器的路径（根目录的index.js），它提供了两个方法，`module`和`getAll`，顾名思义，`module`方法定义模块，`getAll`方法获得所有模块。\n\n先来创建`index.js`，使最开始的测试代码通过：\n\n```javascript\nexports = module.exports = function() {\n\treturn {\n\t\tmodule: function() {\n\n\t\t},\n\t\tgetAll: function() {\n\n\t\t}\n\t}\n}\n```\n\n运行`mocha`，一片绿灯。\n\n现在可以定义我们的第一个模块了，在测试代码中添加以下内容：\n\n```javascript\nit('define module1', function() {\n\tMyModule.module('module1', [], function() {\n\t\t\tlet tmp = 123\n\t\t\treturn {\n\t\t\t\tfoo: tmp\n\t\t\t}\n\t})\n\n\texpect(MyModule.getAll()).has.a.property('module1')\n})\n```\n\nmodule1不依赖任何模块，所以第二个参数是个空数组，第三个参数定义了module1作为模块被注入其它模块时提供了什么，注意到这个函数中有个私有变量tmp，为了证明稍后这里形成了闭包，我们把暴露出去的foo属性指向了tmp，稍后在module2中我们会尝试访问它。\n\n现在运行测试代码，当然不会通过，我们来为这段测试脚本更新index.js。\n\n```javascript\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\n内部的私有变量modules是个哈希列表，因为模块名是**唯一的不重名的字符串**，我们自然的想到用这样的数据结构储存它，module方法简单的把模块和相关信息放到了modules里，而getAll方法则直接返回了modules。\n\n这样，我们通过了第二段测试。\n\n继续往下，在测试代码中定义第二个模块：\n\n```javascript\nit('define module2', function() {\n\tMyModule.module('module2', ['module1'], function(module1) {\n\t\texpect(module1.foo).to.equal(123)\n\t\treturn {\n\t\t\ta: 456,\n\t\t\tref: module1\n\t\t}\n\t})\n\texpect(MyModule.getAll()).has.a.property('module2')\n})\n```\n\nmodule1被注入到了module2中，并且在module2里我们尝试访问module1的foo属性，如果一切顺利，它应该是`123`。\n\n实现上面的逻辑我们需要对MyModule的module方法里的第二个参数做一些处理，现在来修改index.js：\n\n```Javascript\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tfunction enumerateInjects(injects) {\n\t\t\t\tlet tmp = [];\n\n\t\t\t\tfor (let i in injects) {\n\t\t\t\t\tif (modules[injects[i]]) {\n\t\t\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\n\t\t\tbody.apply(this, enumerateInjects(injects))\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\nenumerateInjects函数遍历了injects参数，把对应模块执行，并将执行后的结果放到一个数组里返回，并且我们还额外做了一点错误处理（当指定要依赖的模块不存在时抛出错误）。在module方法的最后，我们把得到的数组传给了body函数，apply方法在这里很关键，第二个参数数组被展开成了多个参数，于是module2拿到了module1执行后的结果。\n\n此时再运行一遍测试脚本，比预料的还要顺利。\n\n看上去我们的构造器完成了，module1顺利注入到了module2里，实际上到此为止module1确实构成了一个模块，可以被注入到任何模块中。但我们考虑的还不够，我们应该继续往下，尝试构造module3，把module1和module2都注入进去看看会发生什么。\n\n补充测试脚本：\n\n```javascript\nit('define module3', function() {\n\tMyModule.module('module3', ['module1', 'module2'], function(module1, module2) {\n\t\texpect(module1.foo).to.equal(123)\n\t\texpect(module2.a).to.equal(456)\n\t\texpect(module2.ref.foo).to.equal(123)\n\n\t})\n\n\texpect(MyModule.getAll()).has.a.property('module3')\n})\n```\n\n再次运行测试，没有通过。控制台抛出了TypeError错误，告诉我们这里引用了不存在的属性。\n\n思考index.js里的代码，我们假定module1的注入没有问题（事实上确实没问题，因为前面已经经过检验），当我们把module2注入module3时enumerateInjects函数做了什么？\n\nmodule2依赖module1，但遍历过程中我们却忽略了这一点，直接执行module2的body而不考虑它在定义时声明的依赖，若module1此时没有注入到module2里，自然不可能得到我们预期的结果。\n\n对enumerateInjects函数做如下修改：\n\n```Javascript\nfunction enumerateInjects(injects) {\n\tlet tmp = [];\n    for (let i in injects) {\n\t\tif (modules[injects[i]]) {\n\t\t\tif (modules[injects[i]].dependencies.length > 0) {\n\t\t\t\tlet deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);\n\n\t\t\t\ttmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))\n\t\t\t} else {\n\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n        }\n\t}\n\n\treturn tmp;\n}\n```\n\n在第一个if判断里我们添加了对依赖的依赖的依赖…的处理，没错，这是个**递归**，无论模块嵌套有多深，在有限的深度里我们都可以将它一个个找到并最终传递给当前模块。\n\n到此，测试脚本顺利运行。最终我们的module.js和index.js如下：\n\n```Javascript\n// module.js\nlet expect = require('chai').expect;\n\ndescribe('My module tests', function() {\n\tlet MyModule;\n\n\tbefore(function(done) {\n\t\tMyModule = require('../index.js')()\n\n\t\tdone()\n\t})\n\n\tit('desc MyModule', function() {\n\t\texpect(MyModule).has.a.property('module')\n\t\texpect(MyModule).has.a.property('getAll')\n\t})\n\n\tit('define module1', function() {\n\t\tMyModule.module('module1', [], function() {\n\t\t\tlet tmp = 123\n\t\t\treturn {\n\t\t\t\tfoo: tmp\n\t\t\t}\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module1')\n\t})\n\n\tit('define module2', function() {\n\t\tMyModule.module('module2', ['module1'], function(module1) {\n\t\t\texpect(module1.foo).to.equal(123)\n\n\t\t\treturn {\n\t\t\t\ta: 456,\n\t\t\t\tref: module1\n\t\t\t}\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module2')\n\t})\n\n\tit('define module3', function() {\n\t\tMyModule.module('module3', ['module1', 'module2'], function(module1, module2) {\n\t\t\texpect(module1.foo).to.equal(123)\n\t\t\texpect(module2.a).to.equal(456)\n\t\t\texpect(module2.ref.foo).to.equal(123)\n\n\t\t})\n\n\t\texpect(MyModule.getAll()).has.a.property('module3')\n\t})\n\n})\n```\n\n```Javascript\n// index.js\nexports = module.exports = function() {\n\n\tlet modules = {};\n\n\treturn {\n\t\tmodule: function(name, injects, body) {\n\n\t\t\tfunction enumerateInjects(injects) {\n\t\t\t\tlet tmp = [];\n\t\t\t\tfor (let i in injects) {\n\t\t\t\t\tif (modules[injects[i]]) {\n\t\t\t\t\t\tif (modules[injects[i]].dependencies.length > 0) {\n\t\t\t\t\t\t\tlet deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);\n\n\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body())\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Inject error. No module named ${injects[i]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\n\t\t\tmodules[name] = {\n\t\t\t\tdependencies: injects,\n\t\t\t\tbody: body\n\t\t\t};\n\n\t\t\tbody.apply(this, enumerateInjects(injects))\n\t\t},\n\t\tgetAll: function() {\n\t\t\treturn modules;\n\t\t}\n\t}\n}\n```\n\n本文的最后，我们定义的module3其实并不是一个模块，因为它没有满足篇头结论里的第二条。因此在别的模块中注入它是毫无意义的。\n\n良好的模块定义和管理在协作开发中至关重要，模块模式并没有什么最佳实践，有的只是对经验的不段总结，本文说述的也只是模块模式的凤毛麟角。\n\n本篇文章里的代码不建议用到生产环境中，建议使用优秀的方案如[require.js](https://github.com/requirejs/requirejs)。\n\n完整源码地址：[github](https://github.com/cyyyu/inc)\n\n","slug":"什么是模块","published":1,"updated":"2016-11-16T05:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu2eolm00064n9kles7403e","content":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>阅读下文假定你基本了解：使用<code>mocha</code>做单元测试，angularjs，nodejs环境搭建以及npm的使用。</p>\n<p>先说结论：</p>\n<ul>\n<li><p>被函数包装，每次调用实例化一个新的对象或返回同一个对象（单例模式下，函数至少需要调用一次）</p>\n</li>\n<li><p>上述函数中有内部函数暴露出来，使其内部作用域形成闭包。</p>\n</li>\n</ul>\n<p>Angularjs是个很’模块化’的框架，这里不谈MVC，MVVM，指令，服务。谈谈ng中的依赖注入，ng出世时最为人称道的概念之一。</p>\n<p>基于上述结论我会写个模块构造器，以这个例子来说明如何创建一个模块。</p>\n<p>以下ng指代angular。</p>\n<h3 id=\"ng中的依赖注入\"><a href=\"#ng中的依赖注入\" class=\"headerlink\" title=\"ng中的依赖注入\"></a>ng中的依赖注入</h3><p>在ng中，当我们要创建一个不依赖任何模块的模块<code>foo</code>，我们这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'foo'</span>, [])</div></pre></td></tr></table></figure>\n<p>当我们要创建另一个依赖上述<code>foo</code>模块的另一个模块时我们这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'another'</span>, [<span class=\"string\">'foo'</span>])</div></pre></td></tr></table></figure>\n<p>这就是最简单的依赖注入。</p>\n<p>在第一个<code>foo</code>模块中，由于angular的module方法返回angular自身，我们可以像jQuery那样链式调用，在其后创建模块中的<code>service</code>，就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'foo'</span>, []).service(<span class=\"string\">'fooService'</span>, [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123;&#125;])</div></pre></td></tr></table></figure>\n<p>当<code>another</code>声明自己依赖<code>foo</code>时，<code>foo</code>中的service<strong>注入</strong>了<code>another</code>，在这个过程中，angular帮助我们完成了篇头的<strong>结论一</strong>，模块<code>another</code>接着创建controller时可以使用foo中已经创建好的service：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'another'</span>, [<span class=\"string\">'foo'</span>]).controller(<span class=\"string\">'anotherCtrl'</span>, [<span class=\"string\">'fooService'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fooService</span>)</span>&#123;&#125;])</div></pre></td></tr></table></figure>\n<p>我们注意到一个细节，controller方法的第二个参数是一个数组，数组的第一个元素声明了所依赖的模块名，而数组的最后一个元素是个匿名函数，<code>fooService</code>在这里被当做参数<strong>注入</strong>了，显然，在这个匿名函数里你可以调用fooService实例化后暴露的公共api，访问到到原始fooService里的私有变量，js程序员不可能不知道，这就是<strong>闭包</strong>。</p>\n<h3 id=\"我们的模块\"><a href=\"#我们的模块\" class=\"headerlink\" title=\"我们的模块\"></a>我们的模块</h3><p>ng里的controller，service等可以视为子模块，简单起见，我们的模块去掉了这些概念，但保留了依赖注入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">MyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>)</span>&#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">MyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>上面的代码中，<code>MyModule</code>定义了三个模块，module1不依赖任何模块，module2依赖module1，module3依赖module1和module2。</p>\n<p>为了实现上述的模式，我们来先写一点测试。</p>\n<p>创建一个空项目目录，在根目录创建test文件夹，并且在test文件夹内创建module.js文件，下面是module.js文件的内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'My module tests'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> MyModule;</div><div class=\"line\"></div><div class=\"line\">\tbefore(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">\t\tMyModule = <span class=\"built_in\">require</span>(<span class=\"string\">'../index.js'</span>)()</div><div class=\"line\"></div><div class=\"line\">\t\tdone()</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'desc MyModule'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'module'</span>)</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'getAll'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在测试代码里我们指明了模块构造器的路径（根目录的index.js），它提供了两个方法，<code>module</code>和<code>getAll</code>，顾名思义，<code>module</code>方法定义模块，<code>getAll</code>方法获得所有模块。</p>\n<p>先来创建<code>index.js</code>，使最开始的测试代码通过：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行<code>mocha</code>，一片绿灯。</p>\n<p>现在可以定义我们的第一个模块了，在测试代码中添加以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">foo</span>: tmp</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module1'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>module1不依赖任何模块，所以第二个参数是个空数组，第三个参数定义了module1作为模块被注入其它模块时提供了什么，注意到这个函数中有个私有变量tmp，为了证明稍后这里形成了闭包，我们把暴露出去的foo属性指向了tmp，稍后在module2中我们会尝试访问它。</p>\n<p>现在运行测试代码，当然不会通过，我们来为这段测试脚本更新index.js。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内部的私有变量modules是个哈希列表，因为模块名是<strong>唯一的不重名的字符串</strong>，我们自然的想到用这样的数据结构储存它，module方法简单的把模块和相关信息放到了modules里，而getAll方法则直接返回了modules。</p>\n<p>这样，我们通过了第二段测试。</p>\n<p>继续往下，在测试代码中定义第二个模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>) </span>&#123;</div><div class=\"line\">\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"attr\">a</span>: <span class=\"number\">456</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">ref</span>: module1</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module2'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>module1被注入到了module2中，并且在module2里我们尝试访问module1的foo属性，如果一切顺利，它应该是<code>123</code>。</p>\n<p>实现上面的逻辑我们需要对MyModule的module方法里的第二个参数做一些处理，现在来修改index.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\t\tbody.apply(<span class=\"keyword\">this</span>, enumerateInjects(injects))</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>enumerateInjects函数遍历了injects参数，把对应模块执行，并将执行后的结果放到一个数组里返回，并且我们还额外做了一点错误处理（当指定要依赖的模块不存在时抛出错误）。在module方法的最后，我们把得到的数组传给了body函数，apply方法在这里很关键，第二个参数数组被展开成了多个参数，于是module2拿到了module1执行后的结果。</p>\n<p>此时再运行一遍测试脚本，比预料的还要顺利。</p>\n<p>看上去我们的构造器完成了，module1顺利注入到了module2里，实际上到此为止module1确实构成了一个模块，可以被注入到任何模块中。但我们考虑的还不够，我们应该继续往下，尝试构造module3，把module1和module2都注入进去看看会发生什么。</p>\n<p>补充测试脚本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>) </span>&#123;</div><div class=\"line\">\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\texpect(module2.a).to.equal(<span class=\"number\">456</span>)</div><div class=\"line\">\t\texpect(module2.ref.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module3'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>再次运行测试，没有通过。控制台抛出了TypeError错误，告诉我们这里引用了不存在的属性。</p>\n<p>思考index.js里的代码，我们假定module1的注入没有问题（事实上确实没问题，因为前面已经经过检验），当我们把module2注入module3时enumerateInjects函数做了什么？</p>\n<p>module2依赖module1，但遍历过程中我们却忽略了这一点，直接执行module2的body而不考虑它在定义时声明的依赖，若module1此时没有注入到module2里，自然不可能得到我们预期的结果。</p>\n<p>对enumerateInjects函数做如下修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]].dependencies.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\ttmp.push(modules[injects[i]].body.apply(<span class=\"literal\">null</span>, deepEnumerateInjects))</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在第一个if判断里我们添加了对依赖的依赖的依赖…的处理，没错，这是个<strong>递归</strong>，无论模块嵌套有多深，在有限的深度里我们都可以将它一个个找到并最终传递给当前模块。</p>\n<p>到此，测试脚本顺利运行。最终我们的module.js和index.js如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// module.js</span></div><div class=\"line\"><span class=\"keyword\">let</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'My module tests'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> MyModule;</div><div class=\"line\"></div><div class=\"line\">\tbefore(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">\t\tMyModule = <span class=\"built_in\">require</span>(<span class=\"string\">'../index.js'</span>)()</div><div class=\"line\"></div><div class=\"line\">\t\tdone()</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'desc MyModule'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'module'</span>)</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'getAll'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">foo</span>: tmp</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module1'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>) </span>&#123;</div><div class=\"line\">\t\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">a</span>: <span class=\"number\">456</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">ref</span>: module1</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module2'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>) </span>&#123;</div><div class=\"line\">\t\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\t\texpect(module2.a).to.equal(<span class=\"number\">456</span>)</div><div class=\"line\">\t\t\texpect(module2.ref.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module3'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.js</span></div><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]].dependencies.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">let</span> deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body.apply(<span class=\"literal\">null</span>, deepEnumerateInjects))</div><div class=\"line\">\t\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\t\tbody.apply(<span class=\"keyword\">this</span>, enumerateInjects(injects))</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文的最后，我们定义的module3其实并不是一个模块，因为它没有满足篇头结论里的第二条。因此在别的模块中注入它是毫无意义的。</p>\n<p>良好的模块定义和管理在协作开发中至关重要，模块模式并没有什么最佳实践，有的只是对经验的不段总结，本文说述的也只是模块模式的凤毛麟角。</p>\n<p>本篇文章里的代码不建议用到生产环境中，建议使用优秀的方案如<a href=\"https://github.com/requirejs/requirejs\" target=\"_blank\" rel=\"external\">require.js</a>。</p>\n<p>完整源码地址：<a href=\"https://github.com/cyyyu/inc\" target=\"_blank\" rel=\"external\">github</a></p>\n","excerpt":"","more":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>阅读下文假定你基本了解：使用<code>mocha</code>做单元测试，angularjs，nodejs环境搭建以及npm的使用。</p>\n<p>先说结论：</p>\n<ul>\n<li><p>被函数包装，每次调用实例化一个新的对象或返回同一个对象（单例模式下，函数至少需要调用一次）</p>\n</li>\n<li><p>上述函数中有内部函数暴露出来，使其内部作用域形成闭包。</p>\n</li>\n</ul>\n<p>Angularjs是个很’模块化’的框架，这里不谈MVC，MVVM，指令，服务。谈谈ng中的依赖注入，ng出世时最为人称道的概念之一。</p>\n<p>基于上述结论我会写个模块构造器，以这个例子来说明如何创建一个模块。</p>\n<p>以下ng指代angular。</p>\n<h3 id=\"ng中的依赖注入\"><a href=\"#ng中的依赖注入\" class=\"headerlink\" title=\"ng中的依赖注入\"></a>ng中的依赖注入</h3><p>在ng中，当我们要创建一个不依赖任何模块的模块<code>foo</code>，我们这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'foo'</span>, [])</div></pre></td></tr></table></figure>\n<p>当我们要创建另一个依赖上述<code>foo</code>模块的另一个模块时我们这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'another'</span>, [<span class=\"string\">'foo'</span>])</div></pre></td></tr></table></figure>\n<p>这就是最简单的依赖注入。</p>\n<p>在第一个<code>foo</code>模块中，由于angular的module方法返回angular自身，我们可以像jQuery那样链式调用，在其后创建模块中的<code>service</code>，就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'foo'</span>, []).service(<span class=\"string\">'fooService'</span>, [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123;&#125;])</div></pre></td></tr></table></figure>\n<p>当<code>another</code>声明自己依赖<code>foo</code>时，<code>foo</code>中的service<strong>注入</strong>了<code>another</code>，在这个过程中，angular帮助我们完成了篇头的<strong>结论一</strong>，模块<code>another</code>接着创建controller时可以使用foo中已经创建好的service：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(<span class=\"string\">'another'</span>, [<span class=\"string\">'foo'</span>]).controller(<span class=\"string\">'anotherCtrl'</span>, [<span class=\"string\">'fooService'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fooService</span>)</span>&#123;&#125;])</div></pre></td></tr></table></figure>\n<p>我们注意到一个细节，controller方法的第二个参数是一个数组，数组的第一个元素声明了所依赖的模块名，而数组的最后一个元素是个匿名函数，<code>fooService</code>在这里被当做参数<strong>注入</strong>了，显然，在这个匿名函数里你可以调用fooService实例化后暴露的公共api，访问到到原始fooService里的私有变量，js程序员不可能不知道，这就是<strong>闭包</strong>。</p>\n<h3 id=\"我们的模块\"><a href=\"#我们的模块\" class=\"headerlink\" title=\"我们的模块\"></a>我们的模块</h3><p>ng里的controller，service等可以视为子模块，简单起见，我们的模块去掉了这些概念，但保留了依赖注入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">MyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>)</span>&#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">MyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>上面的代码中，<code>MyModule</code>定义了三个模块，module1不依赖任何模块，module2依赖module1，module3依赖module1和module2。</p>\n<p>为了实现上述的模式，我们来先写一点测试。</p>\n<p>创建一个空项目目录，在根目录创建test文件夹，并且在test文件夹内创建module.js文件，下面是module.js文件的内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'My module tests'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> MyModule;</div><div class=\"line\"></div><div class=\"line\">\tbefore(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">\t\tMyModule = <span class=\"built_in\">require</span>(<span class=\"string\">'../index.js'</span>)()</div><div class=\"line\"></div><div class=\"line\">\t\tdone()</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'desc MyModule'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'module'</span>)</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'getAll'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在测试代码里我们指明了模块构造器的路径（根目录的index.js），它提供了两个方法，<code>module</code>和<code>getAll</code>，顾名思义，<code>module</code>方法定义模块，<code>getAll</code>方法获得所有模块。</p>\n<p>先来创建<code>index.js</code>，使最开始的测试代码通过：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行<code>mocha</code>，一片绿灯。</p>\n<p>现在可以定义我们的第一个模块了，在测试代码中添加以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">foo</span>: tmp</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module1'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>module1不依赖任何模块，所以第二个参数是个空数组，第三个参数定义了module1作为模块被注入其它模块时提供了什么，注意到这个函数中有个私有变量tmp，为了证明稍后这里形成了闭包，我们把暴露出去的foo属性指向了tmp，稍后在module2中我们会尝试访问它。</p>\n<p>现在运行测试代码，当然不会通过，我们来为这段测试脚本更新index.js。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内部的私有变量modules是个哈希列表，因为模块名是<strong>唯一的不重名的字符串</strong>，我们自然的想到用这样的数据结构储存它，module方法简单的把模块和相关信息放到了modules里，而getAll方法则直接返回了modules。</p>\n<p>这样，我们通过了第二段测试。</p>\n<p>继续往下，在测试代码中定义第二个模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>) </span>&#123;</div><div class=\"line\">\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"attr\">a</span>: <span class=\"number\">456</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">ref</span>: module1</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module2'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>module1被注入到了module2中，并且在module2里我们尝试访问module1的foo属性，如果一切顺利，它应该是<code>123</code>。</p>\n<p>实现上面的逻辑我们需要对MyModule的module方法里的第二个参数做一些处理，现在来修改index.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\t\tbody.apply(<span class=\"keyword\">this</span>, enumerateInjects(injects))</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>enumerateInjects函数遍历了injects参数，把对应模块执行，并将执行后的结果放到一个数组里返回，并且我们还额外做了一点错误处理（当指定要依赖的模块不存在时抛出错误）。在module方法的最后，我们把得到的数组传给了body函数，apply方法在这里很关键，第二个参数数组被展开成了多个参数，于是module2拿到了module1执行后的结果。</p>\n<p>此时再运行一遍测试脚本，比预料的还要顺利。</p>\n<p>看上去我们的构造器完成了，module1顺利注入到了module2里，实际上到此为止module1确实构成了一个模块，可以被注入到任何模块中。但我们考虑的还不够，我们应该继续往下，尝试构造module3，把module1和module2都注入进去看看会发生什么。</p>\n<p>补充测试脚本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'define module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tMyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>) </span>&#123;</div><div class=\"line\">\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\texpect(module2.a).to.equal(<span class=\"number\">456</span>)</div><div class=\"line\">\t\texpect(module2.ref.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module3'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>再次运行测试，没有通过。控制台抛出了TypeError错误，告诉我们这里引用了不存在的属性。</p>\n<p>思考index.js里的代码，我们假定module1的注入没有问题（事实上确实没问题，因为前面已经经过检验），当我们把module2注入module3时enumerateInjects函数做了什么？</p>\n<p>module2依赖module1，但遍历过程中我们却忽略了这一点，直接执行module2的body而不考虑它在定义时声明的依赖，若module1此时没有注入到module2里，自然不可能得到我们预期的结果。</p>\n<p>对enumerateInjects函数做如下修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]].dependencies.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\ttmp.push(modules[injects[i]].body.apply(<span class=\"literal\">null</span>, deepEnumerateInjects))</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在第一个if判断里我们添加了对依赖的依赖的依赖…的处理，没错，这是个<strong>递归</strong>，无论模块嵌套有多深，在有限的深度里我们都可以将它一个个找到并最终传递给当前模块。</p>\n<p>到此，测试脚本顺利运行。最终我们的module.js和index.js如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// module.js</span></div><div class=\"line\"><span class=\"keyword\">let</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'My module tests'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> MyModule;</div><div class=\"line\"></div><div class=\"line\">\tbefore(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">\t\tMyModule = <span class=\"built_in\">require</span>(<span class=\"string\">'../index.js'</span>)()</div><div class=\"line\"></div><div class=\"line\">\t\tdone()</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'desc MyModule'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'module'</span>)</div><div class=\"line\">\t\texpect(MyModule).has.a.property(<span class=\"string\">'getAll'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module1'</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">foo</span>: tmp</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module1'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module2'</span>, [<span class=\"string\">'module1'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1</span>) </span>&#123;</div><div class=\"line\">\t\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">a</span>: <span class=\"number\">456</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">ref</span>: module1</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module2'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\tit(<span class=\"string\">'define module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tMyModule.module(<span class=\"string\">'module3'</span>, [<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1, module2</span>) </span>&#123;</div><div class=\"line\">\t\t\texpect(module1.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\">\t\t\texpect(module2.a).to.equal(<span class=\"number\">456</span>)</div><div class=\"line\">\t\t\texpect(module2.ref.foo).to.equal(<span class=\"number\">123</span>)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\t\texpect(MyModule.getAll()).has.a.property(<span class=\"string\">'module3'</span>)</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.js</span></div><div class=\"line\">exports = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">let</span> modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">module</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, injects, body</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerateInjects</span>(<span class=\"params\">injects</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> tmp = [];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> injects) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]]) &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (modules[injects[i]].dependencies.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">let</span> deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body.apply(<span class=\"literal\">null</span>, deepEnumerateInjects))</div><div class=\"line\">\t\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t\ttmp.push(modules[injects[i]].body())</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Inject error. No module named <span class=\"subst\">$&#123;injects[i]&#125;</span>`</span>);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tmodules[name] = &#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dependencies</span>: injects,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">body</span>: body</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\t\tbody.apply(<span class=\"keyword\">this</span>, enumerateInjects(injects))</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">getAll</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> modules;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文的最后，我们定义的module3其实并不是一个模块，因为它没有满足篇头结论里的第二条。因此在别的模块中注入它是毫无意义的。</p>\n<p>良好的模块定义和管理在协作开发中至关重要，模块模式并没有什么最佳实践，有的只是对经验的不段总结，本文说述的也只是模块模式的凤毛麟角。</p>\n<p>本篇文章里的代码不建议用到生产环境中，建议使用优秀的方案如<a href=\"https://github.com/requirejs/requirejs\">require.js</a>。</p>\n<p>完整源码地址：<a href=\"https://github.com/cyyyu/inc\">github</a></p>\n"},{"title":"redis操作中的原子性问题","date":"2017-01-23T09:24:57.000Z","_content":"\n本文涉及的代码均在redis3.2.6版本下测试。\n\n问题的产生来自于这样的需求：\n\n1. 获得一份数据A([time, data])\n2. 从redis**列表**中读取数据B([time, data])\n3. 比较A、B两者的时间间隔，如果大于某个值，将A插入在B后，否则用A的数据更新B\n4. 若A被插入，则判断列表的长度，如果大于100，则删除最旧的一个数据\n\nredis支持简单事务，最开始考虑这个需求的时候想的也是用事务实现即可，但仔细研究了一会redis中的事务，发现的以下问题让我不得不另外寻找更好的解决方案。\n\n1. 一旦开始执行，事务中如果一个命令出错，其它命令仍然会正常执行，也就是说这种情况下不会回滚。这样设计的原因和利弊我无法说清，对我而言是比较不能接受，尽管严谨的代码能够避免大部分错误，但谁能保证永远正常运行呢，举个例子：内存不够了怎么办？\n2. 在获取和更新操作之间，多个客户端有可能获取到同样的值。redis只保证单个事务内部命令的原子性，却不能保证事务间的原子性。\n\n","source":"_drafts/redis操作中的原子性问题.md","raw":"---\ntitle: redis操作中的原子性问题\ndate: 2017-01-23 17:24:57\ntags:\n---\n\n本文涉及的代码均在redis3.2.6版本下测试。\n\n问题的产生来自于这样的需求：\n\n1. 获得一份数据A([time, data])\n2. 从redis**列表**中读取数据B([time, data])\n3. 比较A、B两者的时间间隔，如果大于某个值，将A插入在B后，否则用A的数据更新B\n4. 若A被插入，则判断列表的长度，如果大于100，则删除最旧的一个数据\n\nredis支持简单事务，最开始考虑这个需求的时候想的也是用事务实现即可，但仔细研究了一会redis中的事务，发现的以下问题让我不得不另外寻找更好的解决方案。\n\n1. 一旦开始执行，事务中如果一个命令出错，其它命令仍然会正常执行，也就是说这种情况下不会回滚。这样设计的原因和利弊我无法说清，对我而言是比较不能接受，尽管严谨的代码能够避免大部分错误，但谁能保证永远正常运行呢，举个例子：内存不够了怎么办？\n2. 在获取和更新操作之间，多个客户端有可能获取到同样的值。redis只保证单个事务内部命令的原子性，却不能保证事务间的原子性。\n\n","slug":"redis操作中的原子性问题","published":0,"updated":"2017-01-24T11:10:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciying3460000w13jg7i41hyi","content":"<p>本文涉及的代码均在redis3.2.6版本下测试。</p>\n<p>问题的产生来自于这样的需求：</p>\n<ol>\n<li>获得一份数据A([time, data])</li>\n<li>从redis<strong>列表</strong>中读取数据B([time, data])</li>\n<li>比较A、B两者的时间间隔，如果大于某个值，将A插入在B后，否则用A的数据更新B</li>\n<li>若A被插入，则判断列表的长度，如果大于100，则删除最旧的一个数据</li>\n</ol>\n<p>redis支持简单事务，最开始考虑这个需求的时候想的也是用事务实现即可，但仔细研究了一会redis中的事务，发现的以下问题让我不得不另外寻找更好的解决方案。</p>\n<ol>\n<li>一旦开始执行，事务中如果一个命令出错，其它命令仍然会正常执行，也就是说这种情况下不会回滚。这样设计的原因和利弊我无法说清，对我而言是比较不能接受，尽管严谨的代码能够避免大部分错误，但谁能保证永远正常运行呢，举个例子：内存不够了怎么办？</li>\n<li>在获取和更新操作之间，多个客户端有可能获取到同样的值。redis只保证单个事务内部命令的原子性，却不能保证事务间的原子性。</li>\n</ol>\n","excerpt":"","more":"<p>本文涉及的代码均在redis3.2.6版本下测试。</p>\n<p>问题的产生来自于这样的需求：</p>\n<ol>\n<li>获得一份数据A([time, data])</li>\n<li>从redis<strong>列表</strong>中读取数据B([time, data])</li>\n<li>比较A、B两者的时间间隔，如果大于某个值，将A插入在B后，否则用A的数据更新B</li>\n<li>若A被插入，则判断列表的长度，如果大于100，则删除最旧的一个数据</li>\n</ol>\n<p>redis支持简单事务，最开始考虑这个需求的时候想的也是用事务实现即可，但仔细研究了一会redis中的事务，发现的以下问题让我不得不另外寻找更好的解决方案。</p>\n<ol>\n<li>一旦开始执行，事务中如果一个命令出错，其它命令仍然会正常执行，也就是说这种情况下不会回滚。这样设计的原因和利弊我无法说清，对我而言是比较不能接受，尽管严谨的代码能够避免大部分错误，但谁能保证永远正常运行呢，举个例子：内存不够了怎么办？</li>\n<li>在获取和更新操作之间，多个客户端有可能获取到同样的值。redis只保证单个事务内部命令的原子性，却不能保证事务间的原子性。</li>\n</ol>\n"},{"title":"专注一点","_content":"\n2016年1月23日，正式从科乐离职，很艰难的做出这个决定。\n\n","source":"_drafts/专注一点.md","raw":"---\ntitle: 专注一点\ntags:\n---\n\n2016年1月23日，正式从科乐离职，很艰难的做出这个决定。\n\n","slug":"专注一点","published":0,"date":"2017-01-24T11:11:27.000Z","updated":"2017-01-26T02:59:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciying34a0001w13jf40g6h73","content":"<p>2016年1月23日，正式从科乐离职，很艰难的做出这个决定。</p>\n","excerpt":"","more":"<p>2016年1月23日，正式从科乐离职，很艰难的做出这个决定。</p>\n"},{"title":"面试中的问题","date":"2017-01-29T12:31:42.000Z","_content":"\n\n年前发了个求职贴，一周以来陆续有很多公司对我表示感兴趣，面试和笔试也不少，其中有道笔试题大概是这样的。\n\n```\n把以下数据组成个树打印出来，像npm list命令一样。\nlet testData = [\n    {id:1, name: 'i1'}, \n    {id:2, name:'i2', parentId: 1},\n    {id:4, name:'i4', parentId: 3},\n    {id:3, name:'i3', parentId: 2},\n    {id:8, name:'i8', parentId: 7}\n]\n```\n\n笔试过程不累述，是一家比较喜欢的公司，而当时比较紧张，时间紧迫，只向面试官阐述了思路，勉强过关，却没有写出自己满意的答案。事后想想其实这题并不难，这里做个简单总结，答案并不一定是最好的。\n\n一眼注意到i8是个游离在外的叶子，所以还要处理不在树内的情况，这里后面再说到。这题最大的问题是i4这个叶子的父级是i3，若按顺序遍历的话i3还在i4之后遍历到，就无法将i4挂在i3下。和面试官交流了下，给我的提示是用个全局缓存就好了，当时也确实是这么做的，但总觉得应该有更优雅的处理办法。\n\n对于上述问题我现在的思路是用递归即可，对于无法找到父级的叶子元素，放到遍历对象的尾部再处理，就不需要全局缓存了。\n\n下面说说实现。\n\n首先最终得到的树的结构我定义如下。\n\n```javascript\n{\n  id: xxx,\n  name: xxx,\n  child: {...}\n}\n```\n\n由于此题一眼看去只是个单页树，就全当单页树处理，暂不考虑多叉树的情况。\n\n先实现主函数。\n\n```javascript\nfunction main(parent, arr) {\n\tlet child = arr.shift();\n\t\n\tif(!child) return parent;\n\n\tif(!child.parentId) { // no parent, set as root.\n\t\tif(!parent.id) { // only one root.\n\t\t\tparent = child;\n\t\t}\n\t} else { // got a child.\n\t\tlet ok = setChild(parent, child);\n\t\tif(!ok) { // parent not found.\n\t\t\tif(!ok) {\n\t\t\t\tarr.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn main(parent, arr);\n}\n```\n\n主函数基本实现了我说的思路，首先将数组第一个元素提取出来，然后定义终止条件（即：提取元素失败），接着根据提取出的元素设定为根元素（没有找到parentId）或设定为叶子（找到parentId），然后递归调用自身。\n\n其中setChild函数的实现如下。\n\n```Javascript\nfunction setChild(parent, child) {\n\tlet finded = false; // flag.\n\tif(parent.id === child.parentId) {\n\t\tparent.child = child;\n\t\tfinded = true;\n\t} else if(parent.child) {\n\t\tfinded = setChild(parent.child, child);\n\t}\n\treturn finded;\n}\n```\n\nsetChild同样也是用递归实现，返回true或false表示子元素设置成功或失败。\n\n不过现在尝试运行`main({}, testData)`会造成内存溢出，因为i8始终找不到父级，使得递归永远无法终止。所以我们得改造下main函数，添加合适的错误处理。改造如下。\n\n```javascript\nfunction main(parent, arr, depth) {\n\tlet child = arr.shift();\n\tdepth = depth || 0;\n\n\tif(!child) return parent;\n\n\tif(!child.parentId) { // no parent, set as root.\n\t\tif(!parent.id) { // only one root.\n\t\t\tparent = child;\n\t\t}\n\t} else { // got a child.\n\t\tlet ok = setChild(parent, child);\n\t\tif(!ok) { // parent not found.\n\t\t\tif(depth < 10) {\n\t\t\t\tarr.push(child);\n\t\t\t\tdepth++;\n\t\t\t} else { // ending\n\t\t\t\tconsole.log('These children have no parents: ', arr.concat(child))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn main(parent, arr, ++depth);\n}\n```\n\n更新后的main函数加上了第三个参数depth，可选，且初始为0，每次递归自增1，10次递归后终止，并打印仍未找到父级的元素。完成后的代码运行`console.log(main({}, data))`，结果如下。\n\n```Javascript\nThese children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]\n{ id: 1,\n  name: 'i1',\n  child: \n   { id: 2,\n     name: 'i2',\n     parentId: 1,\n     child: { id: 3, name: 'i3', parentId: 2, child: [Object] } } }\n```\n\n看样子树已经生成了。最后加上个printTree函数，格式化输出。\n\n```Javascript\nfunction printTree(tree, depth) {\n\tdepth = depth || 0;\n\tlet i = depth,\n\t\tstr = '';\n\twhile(i--) {\n\t\tstr += '--'\n\t}\n\tconsole.log(str + 'name: ' + tree.name);\n\tif(tree.child) {\n\t\tprintTree(tree.child, ++depth);\n\t}\n}\n```\n\n然后运行。\n\n```javascript\nlet tree = main({}, data);\nprintTree(tree);\n```\n\n输出。\n\n```javascript\nThese children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]\nname: i1\n--name: i2\n----name: i3\n------name: i4\n```\n\n至此，用了三个递归函数，尽管实现上还有一些问题（递归深度控制，多叉树兼容等），此题算是解出来了。","source":"_posts/面试中的问题.md","raw":"---\ntitle: 面试中的问题\ndate: 2017-01-29 20:31:42\ntags:\n---\n\n\n年前发了个求职贴，一周以来陆续有很多公司对我表示感兴趣，面试和笔试也不少，其中有道笔试题大概是这样的。\n\n```\n把以下数据组成个树打印出来，像npm list命令一样。\nlet testData = [\n    {id:1, name: 'i1'}, \n    {id:2, name:'i2', parentId: 1},\n    {id:4, name:'i4', parentId: 3},\n    {id:3, name:'i3', parentId: 2},\n    {id:8, name:'i8', parentId: 7}\n]\n```\n\n笔试过程不累述，是一家比较喜欢的公司，而当时比较紧张，时间紧迫，只向面试官阐述了思路，勉强过关，却没有写出自己满意的答案。事后想想其实这题并不难，这里做个简单总结，答案并不一定是最好的。\n\n一眼注意到i8是个游离在外的叶子，所以还要处理不在树内的情况，这里后面再说到。这题最大的问题是i4这个叶子的父级是i3，若按顺序遍历的话i3还在i4之后遍历到，就无法将i4挂在i3下。和面试官交流了下，给我的提示是用个全局缓存就好了，当时也确实是这么做的，但总觉得应该有更优雅的处理办法。\n\n对于上述问题我现在的思路是用递归即可，对于无法找到父级的叶子元素，放到遍历对象的尾部再处理，就不需要全局缓存了。\n\n下面说说实现。\n\n首先最终得到的树的结构我定义如下。\n\n```javascript\n{\n  id: xxx,\n  name: xxx,\n  child: {...}\n}\n```\n\n由于此题一眼看去只是个单页树，就全当单页树处理，暂不考虑多叉树的情况。\n\n先实现主函数。\n\n```javascript\nfunction main(parent, arr) {\n\tlet child = arr.shift();\n\t\n\tif(!child) return parent;\n\n\tif(!child.parentId) { // no parent, set as root.\n\t\tif(!parent.id) { // only one root.\n\t\t\tparent = child;\n\t\t}\n\t} else { // got a child.\n\t\tlet ok = setChild(parent, child);\n\t\tif(!ok) { // parent not found.\n\t\t\tif(!ok) {\n\t\t\t\tarr.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn main(parent, arr);\n}\n```\n\n主函数基本实现了我说的思路，首先将数组第一个元素提取出来，然后定义终止条件（即：提取元素失败），接着根据提取出的元素设定为根元素（没有找到parentId）或设定为叶子（找到parentId），然后递归调用自身。\n\n其中setChild函数的实现如下。\n\n```Javascript\nfunction setChild(parent, child) {\n\tlet finded = false; // flag.\n\tif(parent.id === child.parentId) {\n\t\tparent.child = child;\n\t\tfinded = true;\n\t} else if(parent.child) {\n\t\tfinded = setChild(parent.child, child);\n\t}\n\treturn finded;\n}\n```\n\nsetChild同样也是用递归实现，返回true或false表示子元素设置成功或失败。\n\n不过现在尝试运行`main({}, testData)`会造成内存溢出，因为i8始终找不到父级，使得递归永远无法终止。所以我们得改造下main函数，添加合适的错误处理。改造如下。\n\n```javascript\nfunction main(parent, arr, depth) {\n\tlet child = arr.shift();\n\tdepth = depth || 0;\n\n\tif(!child) return parent;\n\n\tif(!child.parentId) { // no parent, set as root.\n\t\tif(!parent.id) { // only one root.\n\t\t\tparent = child;\n\t\t}\n\t} else { // got a child.\n\t\tlet ok = setChild(parent, child);\n\t\tif(!ok) { // parent not found.\n\t\t\tif(depth < 10) {\n\t\t\t\tarr.push(child);\n\t\t\t\tdepth++;\n\t\t\t} else { // ending\n\t\t\t\tconsole.log('These children have no parents: ', arr.concat(child))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn main(parent, arr, ++depth);\n}\n```\n\n更新后的main函数加上了第三个参数depth，可选，且初始为0，每次递归自增1，10次递归后终止，并打印仍未找到父级的元素。完成后的代码运行`console.log(main({}, data))`，结果如下。\n\n```Javascript\nThese children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]\n{ id: 1,\n  name: 'i1',\n  child: \n   { id: 2,\n     name: 'i2',\n     parentId: 1,\n     child: { id: 3, name: 'i3', parentId: 2, child: [Object] } } }\n```\n\n看样子树已经生成了。最后加上个printTree函数，格式化输出。\n\n```Javascript\nfunction printTree(tree, depth) {\n\tdepth = depth || 0;\n\tlet i = depth,\n\t\tstr = '';\n\twhile(i--) {\n\t\tstr += '--'\n\t}\n\tconsole.log(str + 'name: ' + tree.name);\n\tif(tree.child) {\n\t\tprintTree(tree.child, ++depth);\n\t}\n}\n```\n\n然后运行。\n\n```javascript\nlet tree = main({}, data);\nprintTree(tree);\n```\n\n输出。\n\n```javascript\nThese children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]\nname: i1\n--name: i2\n----name: i3\n------name: i4\n```\n\n至此，用了三个递归函数，尽管实现上还有一些问题（递归深度控制，多叉树兼容等），此题算是解出来了。","slug":"面试中的问题","published":1,"updated":"2017-01-29T12:31:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciying34o0002w13jq24fxii9","content":"<p>年前发了个求职贴，一周以来陆续有很多公司对我表示感兴趣，面试和笔试也不少，其中有道笔试题大概是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">把以下数据组成个树打印出来，像npm list命令一样。</div><div class=\"line\">let testData = [</div><div class=\"line\">    &#123;id:1, name: &apos;i1&apos;&#125;, </div><div class=\"line\">    &#123;id:2, name:&apos;i2&apos;, parentId: 1&#125;,</div><div class=\"line\">    &#123;id:4, name:&apos;i4&apos;, parentId: 3&#125;,</div><div class=\"line\">    &#123;id:3, name:&apos;i3&apos;, parentId: 2&#125;,</div><div class=\"line\">    &#123;id:8, name:&apos;i8&apos;, parentId: 7&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>笔试过程不累述，是一家比较喜欢的公司，而当时比较紧张，时间紧迫，只向面试官阐述了思路，勉强过关，却没有写出自己满意的答案。事后想想其实这题并不难，这里做个简单总结，答案并不一定是最好的。</p>\n<p>一眼注意到i8是个游离在外的叶子，所以还要处理不在树内的情况，这里后面再说到。这题最大的问题是i4这个叶子的父级是i3，若按顺序遍历的话i3还在i4之后遍历到，就无法将i4挂在i3下。和面试官交流了下，给我的提示是用个全局缓存就好了，当时也确实是这么做的，但总觉得应该有更优雅的处理办法。</p>\n<p>对于上述问题我现在的思路是用递归即可，对于无法找到父级的叶子元素，放到遍历对象的尾部再处理，就不需要全局缓存了。</p>\n<p>下面说说实现。</p>\n<p>首先最终得到的树的结构我定义如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: xxx,</div><div class=\"line\">  <span class=\"attr\">name</span>: xxx,</div><div class=\"line\">  <span class=\"attr\">child</span>: &#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于此题一眼看去只是个单页树，就全当单页树处理，暂不考虑多叉树的情况。</p>\n<p>先实现主函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">parent, arr</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> child = arr.shift();</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child) <span class=\"keyword\">return</span> parent;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child.parentId) &#123; <span class=\"comment\">// no parent, set as root.</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!parent.id) &#123; <span class=\"comment\">// only one root.</span></div><div class=\"line\">\t\t\tparent = child;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// got a child.</span></div><div class=\"line\">\t\t<span class=\"keyword\">let</span> ok = setChild(parent, child);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!ok) &#123; <span class=\"comment\">// parent not found.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!ok) &#123;</div><div class=\"line\">\t\t\t\tarr.push(child);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> main(parent, arr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主函数基本实现了我说的思路，首先将数组第一个元素提取出来，然后定义终止条件（即：提取元素失败），接着根据提取出的元素设定为根元素（没有找到parentId）或设定为叶子（找到parentId），然后递归调用自身。</p>\n<p>其中setChild函数的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setChild</span>(<span class=\"params\">parent, child</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> finded = <span class=\"literal\">false</span>; <span class=\"comment\">// flag.</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(parent.id === child.parentId) &#123;</div><div class=\"line\">\t\tparent.child = child;</div><div class=\"line\">\t\tfinded = <span class=\"literal\">true</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(parent.child) &#123;</div><div class=\"line\">\t\tfinded = setChild(parent.child, child);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> finded;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>setChild同样也是用递归实现，返回true或false表示子元素设置成功或失败。</p>\n<p>不过现在尝试运行<code>main({}, testData)</code>会造成内存溢出，因为i8始终找不到父级，使得递归永远无法终止。所以我们得改造下main函数，添加合适的错误处理。改造如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">parent, arr, depth</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> child = arr.shift();</div><div class=\"line\">\tdepth = depth || <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child) <span class=\"keyword\">return</span> parent;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child.parentId) &#123; <span class=\"comment\">// no parent, set as root.</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!parent.id) &#123; <span class=\"comment\">// only one root.</span></div><div class=\"line\">\t\t\tparent = child;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// got a child.</span></div><div class=\"line\">\t\t<span class=\"keyword\">let</span> ok = setChild(parent, child);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!ok) &#123; <span class=\"comment\">// parent not found.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(depth &lt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\t\tarr.push(child);</div><div class=\"line\">\t\t\t\tdepth++;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// ending</span></div><div class=\"line\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'These children have no parents: '</span>, arr.concat(child))</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> main(parent, arr, ++depth);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更新后的main函数加上了第三个参数depth，可选，且初始为0，每次递归自增1，10次递归后终止，并打印仍未找到父级的元素。完成后的代码运行<code>console.log(main({}, data))</code>，结果如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">These children have no parents:  [ &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i8'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">7</span> &#125; ]</div><div class=\"line\">&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span>,</div><div class=\"line\">  <span class=\"attr\">child</span>: </div><div class=\"line\">   &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>,</div><div class=\"line\">     <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span>,</div><div class=\"line\">     <span class=\"attr\">parentId</span>: <span class=\"number\">1</span>,</div><div class=\"line\">     <span class=\"attr\">child</span>: &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i3'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span>, <span class=\"attr\">child</span>: [<span class=\"built_in\">Object</span>] &#125; &#125; &#125;</div></pre></td></tr></table></figure>\n<p>看样子树已经生成了。最后加上个printTree函数，格式化输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printTree</span>(<span class=\"params\">tree, depth</span>) </span>&#123;</div><div class=\"line\">\tdepth = depth || <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">let</span> i = depth,</div><div class=\"line\">\t\tstr = <span class=\"string\">''</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(i--) &#123;</div><div class=\"line\">\t\tstr += <span class=\"string\">'--'</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(str + <span class=\"string\">'name: '</span> + tree.name);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(tree.child) &#123;</div><div class=\"line\">\t\tprintTree(tree.child, ++depth);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tree = main(&#123;&#125;, data);</div><div class=\"line\">printTree(tree);</div></pre></td></tr></table></figure>\n<p>输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">These children have no parents:  [ &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i8'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">7</span> &#125; ]</div><div class=\"line\">name: i1</div><div class=\"line\">--name: i2</div><div class=\"line\">----name: i3</div><div class=\"line\">------name: i4</div></pre></td></tr></table></figure>\n<p>至此，用了三个递归函数，尽管实现上还有一些问题（递归深度控制，多叉树兼容等），此题算是解出来了。</p>\n","excerpt":"","more":"<p>年前发了个求职贴，一周以来陆续有很多公司对我表示感兴趣，面试和笔试也不少，其中有道笔试题大概是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">把以下数据组成个树打印出来，像npm list命令一样。</div><div class=\"line\">let testData = [</div><div class=\"line\">    &#123;id:1, name: &apos;i1&apos;&#125;, </div><div class=\"line\">    &#123;id:2, name:&apos;i2&apos;, parentId: 1&#125;,</div><div class=\"line\">    &#123;id:4, name:&apos;i4&apos;, parentId: 3&#125;,</div><div class=\"line\">    &#123;id:3, name:&apos;i3&apos;, parentId: 2&#125;,</div><div class=\"line\">    &#123;id:8, name:&apos;i8&apos;, parentId: 7&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>笔试过程不累述，是一家比较喜欢的公司，而当时比较紧张，时间紧迫，只向面试官阐述了思路，勉强过关，却没有写出自己满意的答案。事后想想其实这题并不难，这里做个简单总结，答案并不一定是最好的。</p>\n<p>一眼注意到i8是个游离在外的叶子，所以还要处理不在树内的情况，这里后面再说到。这题最大的问题是i4这个叶子的父级是i3，若按顺序遍历的话i3还在i4之后遍历到，就无法将i4挂在i3下。和面试官交流了下，给我的提示是用个全局缓存就好了，当时也确实是这么做的，但总觉得应该有更优雅的处理办法。</p>\n<p>对于上述问题我现在的思路是用递归即可，对于无法找到父级的叶子元素，放到遍历对象的尾部再处理，就不需要全局缓存了。</p>\n<p>下面说说实现。</p>\n<p>首先最终得到的树的结构我定义如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: xxx,</div><div class=\"line\">  <span class=\"attr\">name</span>: xxx,</div><div class=\"line\">  <span class=\"attr\">child</span>: &#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于此题一眼看去只是个单页树，就全当单页树处理，暂不考虑多叉树的情况。</p>\n<p>先实现主函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">parent, arr</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> child = arr.shift();</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child) <span class=\"keyword\">return</span> parent;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child.parentId) &#123; <span class=\"comment\">// no parent, set as root.</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!parent.id) &#123; <span class=\"comment\">// only one root.</span></div><div class=\"line\">\t\t\tparent = child;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// got a child.</span></div><div class=\"line\">\t\t<span class=\"keyword\">let</span> ok = setChild(parent, child);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!ok) &#123; <span class=\"comment\">// parent not found.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!ok) &#123;</div><div class=\"line\">\t\t\t\tarr.push(child);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> main(parent, arr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主函数基本实现了我说的思路，首先将数组第一个元素提取出来，然后定义终止条件（即：提取元素失败），接着根据提取出的元素设定为根元素（没有找到parentId）或设定为叶子（找到parentId），然后递归调用自身。</p>\n<p>其中setChild函数的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setChild</span>(<span class=\"params\">parent, child</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> finded = <span class=\"literal\">false</span>; <span class=\"comment\">// flag.</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(parent.id === child.parentId) &#123;</div><div class=\"line\">\t\tparent.child = child;</div><div class=\"line\">\t\tfinded = <span class=\"literal\">true</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(parent.child) &#123;</div><div class=\"line\">\t\tfinded = setChild(parent.child, child);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> finded;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>setChild同样也是用递归实现，返回true或false表示子元素设置成功或失败。</p>\n<p>不过现在尝试运行<code>main({}, testData)</code>会造成内存溢出，因为i8始终找不到父级，使得递归永远无法终止。所以我们得改造下main函数，添加合适的错误处理。改造如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">parent, arr, depth</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> child = arr.shift();</div><div class=\"line\">\tdepth = depth || <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child) <span class=\"keyword\">return</span> parent;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(!child.parentId) &#123; <span class=\"comment\">// no parent, set as root.</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!parent.id) &#123; <span class=\"comment\">// only one root.</span></div><div class=\"line\">\t\t\tparent = child;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// got a child.</span></div><div class=\"line\">\t\t<span class=\"keyword\">let</span> ok = setChild(parent, child);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!ok) &#123; <span class=\"comment\">// parent not found.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(depth &lt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\t\tarr.push(child);</div><div class=\"line\">\t\t\t\tdepth++;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// ending</span></div><div class=\"line\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'These children have no parents: '</span>, arr.concat(child))</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> main(parent, arr, ++depth);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更新后的main函数加上了第三个参数depth，可选，且初始为0，每次递归自增1，10次递归后终止，并打印仍未找到父级的元素。完成后的代码运行<code>console.log(main({}, data))</code>，结果如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">These children have no parents:  [ &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i8'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">7</span> &#125; ]</div><div class=\"line\">&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span>,</div><div class=\"line\">  <span class=\"attr\">child</span>: </div><div class=\"line\">   &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>,</div><div class=\"line\">     <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span>,</div><div class=\"line\">     <span class=\"attr\">parentId</span>: <span class=\"number\">1</span>,</div><div class=\"line\">     <span class=\"attr\">child</span>: &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i3'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span>, <span class=\"attr\">child</span>: [<span class=\"built_in\">Object</span>] &#125; &#125; &#125;</div></pre></td></tr></table></figure>\n<p>看样子树已经生成了。最后加上个printTree函数，格式化输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printTree</span>(<span class=\"params\">tree, depth</span>) </span>&#123;</div><div class=\"line\">\tdepth = depth || <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">let</span> i = depth,</div><div class=\"line\">\t\tstr = <span class=\"string\">''</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(i--) &#123;</div><div class=\"line\">\t\tstr += <span class=\"string\">'--'</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(str + <span class=\"string\">'name: '</span> + tree.name);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(tree.child) &#123;</div><div class=\"line\">\t\tprintTree(tree.child, ++depth);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tree = main(&#123;&#125;, data);</div><div class=\"line\">printTree(tree);</div></pre></td></tr></table></figure>\n<p>输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">These children have no parents:  [ &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'i8'</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">7</span> &#125; ]</div><div class=\"line\">name: i1</div><div class=\"line\">--name: i2</div><div class=\"line\">----name: i3</div><div class=\"line\">------name: i4</div></pre></td></tr></table></figure>\n<p>至此，用了三个递归函数，尽管实现上还有一些问题（递归深度控制，多叉树兼容等），此题算是解出来了。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}