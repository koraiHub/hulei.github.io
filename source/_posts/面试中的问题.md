---
title: 面试中的问题
date: 2017-01-29 20:31:42
tags:
---


年前发了个求职贴，一周以来陆续有很多公司对我表示感兴趣，面试和笔试也不少，其中有道笔试题大概是这样的。

```
把以下数据组成个树打印出来，像npm list命令一样。
let testData = [
    {id:1, name: 'i1'}, 
    {id:2, name:'i2', parentId: 1},
    {id:4, name:'i4', parentId: 3},
    {id:3, name:'i3', parentId: 2},
    {id:8, name:'i8', parentId: 7}
]
```

笔试过程不累述，是一家比较喜欢的公司，而当时比较紧张，时间紧迫，只向面试官阐述了思路，勉强过关，却没有写出自己满意的答案。事后想想其实这题并不难，这里做个简单总结，答案并不一定是最好的。

一眼注意到i8是个游离在外的叶子，所以还要处理不在树内的情况，这里后面再说到。这题最大的问题是i4这个叶子的父级是i3，若按顺序遍历的话i3还在i4之后遍历到，就无法将i4挂在i3下。和面试官交流了下，给我的提示是用个全局缓存就好了，当时也确实是这么做的，但总觉得应该有更优雅的处理办法。

对于上述问题我现在的思路是用递归即可，对于无法找到父级的叶子元素，放到遍历对象的尾部再处理，就不需要全局缓存了。

下面说说实现。

首先最终得到的树的结构我定义如下。

```javascript
{
  id: xxx,
  name: xxx,
  child: {...}
}
```

由于此题一眼看去只是个单页树，就全当单页树处理，暂不考虑多叉树的情况。

先实现主函数。

```javascript
function main(parent, arr) {
	let child = arr.shift();
	
	if(!child) return parent;

	if(!child.parentId) { // no parent, set as root.
		if(!parent.id) { // only one root.
			parent = child;
		}
	} else { // got a child.
		let ok = setChild(parent, child);
		if(!ok) { // parent not found.
			if(!ok) {
				arr.push(child);
			}
		}
	}

	return main(parent, arr);
}
```

主函数基本实现了我说的思路，首先将数组第一个元素提取出来，然后定义终止条件（即：提取元素失败），接着根据提取出的元素设定为根元素（没有找到parentId）或设定为叶子（找到parentId），然后递归调用自身。

其中setChild函数的实现如下。

```Javascript
function setChild(parent, child) {
	let finded = false; // flag.
	if(parent.id === child.parentId) {
		parent.child = child;
		finded = true;
	} else if(parent.child) {
		finded = setChild(parent.child, child);
	}
	return finded;
}
```

setChild同样也是用递归实现，返回true或false表示子元素设置成功或失败。

不过现在尝试运行`main({}, testData)`会造成内存溢出，因为i8始终找不到父级，使得递归永远无法终止。所以我们得改造下main函数，添加合适的错误处理。改造如下。

```javascript
function main(parent, arr, depth) {
	let child = arr.shift();
	depth = depth || 0;

	if(!child) return parent;

	if(!child.parentId) { // no parent, set as root.
		if(!parent.id) { // only one root.
			parent = child;
		}
	} else { // got a child.
		let ok = setChild(parent, child);
		if(!ok) { // parent not found.
			if(depth < 10) {
				arr.push(child);
				depth++;
			} else { // ending
				console.log('These children have no parents: ', arr.concat(child))
			}
		}
	}

	return main(parent, arr, ++depth);
}
```

更新后的main函数加上了第三个参数depth，可选，且初始为0，每次递归自增1，10次递归后终止，并打印仍未找到父级的元素。完成后的代码运行`console.log(main({}, data))`，结果如下。

```Javascript
These children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]
{ id: 1,
  name: 'i1',
  child: 
   { id: 2,
     name: 'i2',
     parentId: 1,
     child: { id: 3, name: 'i3', parentId: 2, child: [Object] } } }
```

看样子树已经生成了。最后加上个printTree函数，格式化输出。

```Javascript
function printTree(tree, depth) {
	depth = depth || 0;
	let i = depth,
		str = '';
	while(i--) {
		str += '--'
	}
	console.log(str + 'name: ' + tree.name);
	if(tree.child) {
		printTree(tree.child, ++depth);
	}
}
```

然后运行。

```javascript
let tree = main({}, data);
printTree(tree);
```

输出。

```javascript
These children have no parents:  [ { id: 8, name: 'i8', parentId: 7 } ]
name: i1
--name: i2
----name: i3
------name: i4
```

至此，用了三个递归函数，尽管实现上还有一些问题（递归深度控制，多叉树兼容等），此题算是解出来了。