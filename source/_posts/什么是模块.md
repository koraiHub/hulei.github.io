---
title: 什么是模块
date: 2016-11-07 08:48:32
tags:
---

### 写在前面

阅读下文假定你基本了解：使用`mocha`做单元测试，angularjs，nodejs环境搭建以及npm的使用。

先说结论：

* 被函数包装，每次调用实例化一个新的对象或返回同一个对象（单例模式下，函数至少需要调用一次）

* 上述函数中有内部函数暴露出来，使其内部作用域形成闭包。


Angularjs是个很'模块化'的框架，这里不谈MVC，MVVM，指令，服务。谈谈ng中的依赖注入，ng出世时最为人称道的概念之一。

基于上述结论我会写个模块构造器，以这个例子来说明如何创建一个模块。

以下ng指代angular。

### ng中的依赖注入

在ng中，当我们要创建一个不依赖任何模块的模块`foo`，我们这样写：

```javascript
angular.module('foo', [])
```

当我们要创建另一个依赖上述`foo`模块的另一个模块时我们这样写：

```javascript
angular.module('another', ['foo'])
```

这就是最简单的依赖注入。

在第一个`foo`模块中，由于angular的module方法返回angular自身，我们可以像jQuery那样链式调用，在其后创建模块中的`service`，就像下面这样：

```javascript
angular.module('foo', []).service('fooService', [function($scope){}])
```

当`another`声明自己依赖`foo`时，`foo`中的service**注入**了`another`，在这个过程中，angular帮助我们完成了篇头的**结论一**，模块`another`接着创建controller时可以使用foo中已经创建好的service：

```javascript
angular.module('another', ['foo']).controller('anotherCtrl', ['fooService', function(fooService){}])
```

我们注意到一个细节，controller方法的第二个参数是一个数组，数组的第一个元素声明了所依赖的模块名，而数组的最后一个元素是个匿名函数，`fooService`在这里被当做参数**注入**了，显然，在这个匿名函数里你可以调用fooService实例化后暴露的公共api，访问到到原始fooService里的私有变量，js程序员不可能不知道，这就是**闭包**。

### 我们的模块

ng里的controller，service等可以视为子模块，简单起见，我们的模块去掉了这些概念，但保留了依赖注入：

```javascript
MyModule.module('module1', [], function(){})

MyModule.module('module2', ['module1'], function(module1){})

MyModule.module('module3', ['module1', 'module2'], function(module1, module2){})
```

上面的代码中，`MyModule`定义了三个模块，module1不依赖任何模块，module2依赖module1，module3依赖module1和module2。

为了实现上述的模式，我们来先写一点测试。

创建一个空项目目录，在根目录创建test文件夹，并且在test文件夹内创建module.js文件，下面是module.js文件的内容：

```Javascript
let expect = require('chai').expect;

describe('My module tests', function() {
	let MyModule;

	before(function(done) {
		MyModule = require('../index.js')()

		done()
	})

	it('desc MyModule', function(){
		expect(MyModule).has.a.property('module')
		expect(MyModule).has.a.property('getAll')
	})
})
```

在测试代码里我们指明了模块构造器的路径（根目录的index.js），它提供了两个方法，`module`和`getAll`，顾名思义，`module`方法定义模块，`getAll`方法获得所有模块。

先来创建`index.js`，使最开始的测试代码通过：

```javascript
exports = module.exports = function() {
	return {
		module: function() {

		},
		getAll: function() {

		}
	}
}
```

运行`mocha`，一片绿灯。

现在可以定义我们的第一个模块了，在测试代码中添加以下内容：

```javascript
it('define module1', function() {
	MyModule.module('module1', [], function() {
			let tmp = 123
			return {
				foo: tmp
			}
	})

	expect(MyModule.getAll()).has.a.property('module1')
})
```

module1不依赖任何模块，所以第二个参数是个空数组，第三个参数定义了module1作为模块被注入其它模块时提供了什么，注意到这个函数中有个私有变量tmp，为了证明稍后这里形成了闭包，我们把暴露出去的foo属性指向了tmp，稍后在module2中我们会尝试访问它。

现在运行测试代码，当然不会通过，我们来为这段测试脚本更新index.js。

```javascript
exports = module.exports = function() {

	let modules = {};

	return {
		module: function(name, injects, body) {

			modules[name] = {
				dependencies: injects,
				body: body
			};
		},
		getAll: function() {
			return modules;
		}
	}
}
```

内部的私有变量modules是个哈希列表，因为模块名是**唯一的不重名的字符串**，我们自然的想到用这样的数据结构储存它，module方法简单的把模块和相关信息放到了modules里，而getAll方法则直接返回了modules。

这样，我们通过了第二段测试。

继续往下，在测试代码中定义第二个模块：

```javascript
it('define module2', function() {
	MyModule.module('module2', ['module1'], function(module1) {
		expect(module1.foo).to.equal(123)
		return {
			a: 456,
			ref: module1
		}
	})
	expect(MyModule.getAll()).has.a.property('module2')
})
```

module1被注入到了module2中，并且在module2里我们尝试访问module1的foo属性，如果一切顺利，它应该是`123`。

实现上面的逻辑我们需要对MyModule的module方法里的第二个参数做一些处理，现在来修改index.js：

```Javascript
exports = module.exports = function() {

	let modules = {};

	return {
		module: function(name, injects, body) {

			function enumerateInjects(injects) {
				let tmp = [];

				for (let i in injects) {
					if (modules[injects[i]]) {
						tmp.push(modules[injects[i]].body())
					} else {
						throw new Error(`Inject error. No module named ${injects[i]}`);
					}
				}

				return tmp;
			}

			modules[name] = {
				dependencies: injects,
				body: body
			};

			body.apply(this, enumerateInjects(injects))
		},
		getAll: function() {
			return modules;
		}
	}
}
```

enumerateInjects函数遍历了injects参数，把对应模块执行，并将执行后的结果放到一个数组里返回，并且我们还额外做了一点错误处理（当指定要依赖的模块不存在时抛出错误）。在module方法的最后，我们把得到的数组传给了body函数，apply方法在这里很关键，第二个参数数组被展开成了多个参数，于是module2拿到了module1执行后的结果。

此时再运行一遍测试脚本，比预料的还要顺利。

看上去我们的构造器完成了，module1顺利注入到了module2里，实际上到此为止module1确实构成了一个模块，可以被注入到任何模块中。但我们考虑的还不够，我们应该继续往下，尝试构造module3，把module1和module2都注入进去看看会发生什么。

补充测试脚本：

```javascript
it('define module3', function() {
	MyModule.module('module3', ['module1', 'module2'], function(module1, module2) {
		expect(module1.foo).to.equal(123)
		expect(module2.a).to.equal(456)
		expect(module2.ref.foo).to.equal(123)

	})

	expect(MyModule.getAll()).has.a.property('module3')
})
```

再次运行测试，没有通过。控制台抛出了TypeError错误，告诉我们这里引用了不存在的属性。

思考index.js里的代码，我们假定module1的注入没有问题（事实上确实没问题，因为前面已经经过检验），当我们把module2注入module3时enumerateInjects函数做了什么？

module2依赖module1，但遍历过程中我们却忽略了这一点，直接执行module2的body而不考虑它在定义时声明的依赖，若module1此时没有注入到module2里，自然不可能得到我们预期的结果。

对enumerateInjects函数做如下修改：

```Javascript
function enumerateInjects(injects) {
	let tmp = [];
    for (let i in injects) {
		if (modules[injects[i]]) {
			if (modules[injects[i]].dependencies.length > 0) {
				let deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);

				tmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))
			} else {
				tmp.push(modules[injects[i]].body())
			}
		} else {
			throw new Error(`Inject error. No module named ${injects[i]}`);
        }
	}

	return tmp;
}
```

在第一个if判断里我们添加了对依赖的依赖的依赖…的处理，没错，这是个**递归**，无论模块嵌套有多深，在有限的深度里我们都可以将它一个个找到并最终传递给当前模块。

到此，测试脚本顺利运行。最终我们的module.js和index.js如下：

```Javascript
// module.js
let expect = require('chai').expect;

describe('My module tests', function() {
	let MyModule;

	before(function(done) {
		MyModule = require('../index.js')()

		done()
	})

	it('desc MyModule', function() {
		expect(MyModule).has.a.property('module')
		expect(MyModule).has.a.property('getAll')
	})

	it('define module1', function() {
		MyModule.module('module1', [], function() {
			let tmp = 123
			return {
				foo: tmp
			}
		})

		expect(MyModule.getAll()).has.a.property('module1')
	})

	it('define module2', function() {
		MyModule.module('module2', ['module1'], function(module1) {
			expect(module1.foo).to.equal(123)

			return {
				a: 456,
				ref: module1
			}
		})

		expect(MyModule.getAll()).has.a.property('module2')
	})

	it('define module3', function() {
		MyModule.module('module3', ['module1', 'module2'], function(module1, module2) {
			expect(module1.foo).to.equal(123)
			expect(module2.a).to.equal(456)
			expect(module2.ref.foo).to.equal(123)

		})

		expect(MyModule.getAll()).has.a.property('module3')
	})

})
```

```Javascript
// index.js
exports = module.exports = function() {

	let modules = {};

	return {
		module: function(name, injects, body) {

			function enumerateInjects(injects) {
				let tmp = [];
				for (let i in injects) {
					if (modules[injects[i]]) {
						if (modules[injects[i]].dependencies.length > 0) {
							let deepEnumerateInjects = enumerateInjects(modules[injects[i]].dependencies);

							tmp.push(modules[injects[i]].body.apply(null, deepEnumerateInjects))
						} else {
							tmp.push(modules[injects[i]].body())
						}
					} else {
						throw new Error(`Inject error. No module named ${injects[i]}`);
					}
				}

				return tmp;
			}

			modules[name] = {
				dependencies: injects,
				body: body
			};

			body.apply(this, enumerateInjects(injects))
		},
		getAll: function() {
			return modules;
		}
	}
}
```

本文的最后，我们定义的module3其实并不是一个模块，因为它没有满足篇头结论里的第二条。因此在别的模块中注入它是毫无意义的。

良好的模块定义和管理在协作开发中至关重要，模块模式并没有什么最佳实践，有的只是对经验的不段总结，本文说述的也只是模块模式的凤毛麟角。

本篇文章里的代码不建议用到生产环境中，建议使用优秀的方案如[require.js](https://github.com/requirejs/requirejs)。

完整源码地址：[github](https://github.com/cyyyu/inc)

